spring是一个简化java企业级开发的一个框架，内部包含了很多技术。
比如：控制反转&依赖注入、面向切面编程、spring事务管理、
通过spring集成其他框架、springmvc、springboot、springcloud等等
spring容器
    spring容器的概念，容器这个名字起的相当好，容器可以放很多东西，
	我们的程序启动的时候会创建spring容器，会给spring容器一个清单，清单中列出了需要创建的对象以及对象依赖关系，
	spring容器会创建和组装好清单中的对象，然后将这些对象存放在spring容器中，当程序中需要使用的时候，可以到容器中查找获取，然后直接使用。
IOC：控制反转
    使用者之前使用B对象的时候都需要自己去创建和组装，而现在这些创建和组装都交给spring容器去给完成了，
	使用者只需要去spring容器中查找需要使用的对象就可以了；
	这个过程中B对象的创建和组装过程被反转了，之前是使用者自己主动去控制的，
	现在交给spring容器去创建和组装了，对象的构建过程被反转了，所以叫做控制反转；
	IOC是是面相对象编程中的一种设计原则，主要是为了降低系统代码的耦合度，让系统利于维护和扩展。
DI：依赖注入
    依赖注入是spring容器中创建对象时给其设置依赖对象的方式，比如给spring一个清单，
	清单中列出了需要创建B对象以及其他的一些对象（可能包含了B类型中需要依赖对象），
	此时spring在创建B对象的时候，会看B对象需要依赖于哪些对象，然后去查找一下清单中有没有包含这些被依赖的对象，
	如果有就去将其创建好，然后将其传递给B对象；
	可能B需要依赖于很多对象，B创建之前完全不需要知道其他对象是否存在或者其他对象在哪里以及被他们是如何创建，
	而spring容器会将B依赖对象主动创建好并将其注入到B中去，
	比如spring容器创建B的时候，发现B需要依赖于A，那么spring容器在清单中找到A的定义并将其创建好之后，注入到B对象中。
总结
	1.	IOC控制反转，是一种设计理念，将对象创建和组装的主动控制权利交给了spring容器去做，
	控制的动作被反转了，降低了系统的耦合度，利于系统维护和扩展，
	主要就是指需要使用的对象的组装控制权被反转了，之前是自己要做的，现在交给spring容器做了。
	2.	DI依赖注入，表示spring容器中创建对象时给其设置依赖对象的方式，
	通过某些注入方式可以让系统更灵活，比如自动注入等可以让系统变的很灵活。
	3.	spring容器：主要负责容器中对象的创建、组装、对象查找、对象生命周期的管理等等操作。
IOC容器
	IOC容器是具有依赖注入功能的容器，负责对象的实例化、对象的初始化，对象和对象之间依赖关系配置、对象的销毁、对外提供对象的查找等操作，
	对象的整个生命周期都是由容器来控制。
	我们需要使用的对象都由ioc容器进行管理，不需要我们再去手动通过new的方式去创建对象，
	由ioc容器直接帮我们组装好，当我们需要使用的时候直接从ioc容器中直接获取就可以了。

Bean概念
	由spring容器管理的对象统称为Bean对象。
	Bean就是普通的java对象，和我们自己new的对象其实是一样的，
	只是这些对象是由spring去创建和管理的，我们需要在配置文件中告诉spring容器需要创建哪些bean对象，
	所以需要先在配置文件中定义好需要创建的bean对象，这些配置统称为bean定义配置元数据信息，
	spring容器通过读取这些bean配置元数据信息来构建和组装我们需要的对象。
BeanFactory接口
	org.springframework.beans.factory.BeanFactory
	spring容器中具有代表性的容器就是BeanFactory接口，这个是spring容器的顶层接口，提供了容器最基本的功能。
    常用的几个方法
		//按bean的id或者别名查找容器中的bean
		Object getBean(String name) throws BeansException

		//这个是一个泛型方法，按照bean的id或者别名查找指定类型的bean，返回指定类型的bean对象
		<T> T getBean(String name, Class<T> requiredType) throws BeansException;

		//返回容器中指定类型的bean对象
		<T> T getBean(Class<T> requiredType) throws BeansException;

		//获取指定类型bean对象的获取器，这个方法比较特别，以后会专门来讲
		<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
ApplicationContext接口
	org.springframework.context.ApplicationContext
	这个接口继承了BeanFactory接口，所以内部包含了BeanFactory所有的功能，
	并且在其上进行了扩展，增加了很多企业级功能，比如AOP、国际化、事件支持等等。
ClassPathXmlApplicationContext类
	org.springframework.context.support.ClassPathXmlApplicationContext
	这个类实现了ApplicationContext接口，注意一下这个类名称包含了ClassPath Xml，
	说明这个容器类可以从classpath中加载bean xml配置文件，然后创建xml中配置的bean对象，一会后面的案例就会用到这个类。
AnnotationConfigApplicationContext类
	org.springframework.context.annotation.AnnotationConfigApplicationContext
	这个类也实现了ApplicationContext接口，注意其类名包含了Annotation和config两个单词，上面我们有说过，
	bean的定义支持xml的方式和注解的方式，当我们使用注解的方式定义bean的时候，就需要用到这个容器来装载了，
	这个容器内部会解析注解来构建构建和管理需要的bean。
	注解的方式相对于xml方式更方便一些，也是我们比较推荐的方式，后面我们会大量使用这种方式，具体会详解。
bean xml配置文件格式
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		   xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
		
		<import resource="引入其他bean xml配置文件" />
		<bean id="bean标识" class="玩转类型名称"/>
		<alias name="bean标识" alias="别名" />

	</beans>
    beans是根元素，下面可以包含任意数量的import、bean、alias元素，下面我们对每个元素进行详解。
	bean元素
	用来定义一个bean对象。
	格式
	<bean id="bean唯一标识" name="bean名称" class="完整类型名称" factory-bean="工厂bean名称" factory-method="工厂方法"/>
	bean名称
	每个bean都有一个名称，叫做bean名称，bean名称在一个spring容器中必须唯一，否则会报错，通过bean名称可以从spring容器获取对应的bean对象。
	bean别名
	相当于人的外号一样，一个人可能有很多外号，当别人喊这个人的名称或者外号的时候，都可以找到这个人。
	那么bean也一样，也可以给bean起几个外号，这个外号在spring中叫做bean的别名，spring容器允许使用者通过名称或者别名获取对应的bean对象。
	bean名称别名定义规则
	名称和别名可以通过bean元素中的id和name来定义，具体定义规则如下：：
	1.	当id存在的时候，不管name有没有，取id为bean的名称
	2.	当id不存在，此时需要看name，name的值可以通过,;或者空格分割，
	最后会按照分隔符得到一个String数组，数组的第一个元素作为bean的名称，其他的作为bean的别名
	3.	当id和name都存在的时候，id为bean名称，name用来定义多个别名
	4.	当id和name都不指定的时候，bean名称自动生成，生成规则下面详细说明
	id和name都未指定
	bean的class的完整类名#编号
	上面的编号是从0开始的，同种类型的没有指定名称的依次递增。
	第一个会有别名，别名为完整的类名。bean名称为完整类名#编号。
	alias元素
	alias元素也可以用来给某个bean定义别名，语法：
	<alias name="需要定义别名的bean" alias="别名" />
	import元素
	当我们的系统比较大的时候，会分成很多模块，每个模块会对应一个bean xml文件，我们可以在一个总的bean xml中对其他bean xml进行汇总，
	相当于把多个bean xml的内容合并到一个里面了，可以通过import元素引入其他bean配置文件。
	<import resource="其他配置文件的位置" />
容器创建bean实例有多少种
	Spring容器内部创建bean实例对象常见的有4种方式。
	    通过反射调用构造方法创建bean对象
		  调用类的构造方法获取对应的bean实例，是使用最多的方式，这种方式只需要在xml bean元素中指定class属性，
		spring容器内部会自动调用该类型的构造方法来创建bean对象，将其放在容器中以供使用。
		语法
		<bean id="bean名称" name="bean名称或者别名" class="bean的完整类型名称">
			<constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
			....
			<constructor-arg index="n" value="bean的值" ref="引用的bean名称" />
		</bean>
			constructor-arg用于指定构造方法参数的值
			index：构造方法中参数的位置，从0开始，依次递增
			value：指定参数的值
			ref：当插入的值为容器内其他bean的时候，这个值为容器中对应bean的名称
		通过静态工厂方法创建bean对象
		语法
		<bean id="bean名称" name="" class="静态工厂完整类名" factory-method="静态工厂的方法">
			<constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
			....
			<constructor-arg index="n" value="bean的值" ref="引用的bean名称" />
		</bean>
		class：指定静态工厂完整的类名
		factory-method：静态工厂中的静态方法，返回需要的对象。
		constructor-arg用于指定静态方法参数的值，用法和上面介绍的构造方法一样。
		spring容器会自动调用静态工厂的静态方法获取指定的对象，将其放在容器中以供使用
		通过实例工厂方法创建bean对象
		让spring容器去调用某些对象的某些实例方法来生成bean对象放在容器中以供使用。
		语法
		<bean id="bean名称" factory-bean="需要调用的实例对象bean名称" factory-method="bean对象中的方法">
			<constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
			....
			<constructor-arg index="n" value="bean的值" ref="引用的bean名称" />
		</bean>
		spring容器以factory-bean的值为bean名称查找对应的bean对象，然后调用该对象中factory-method属性值指定的方法，
		将这个方法返回的对象作为当前bean对象放在容器中供使用。
		通过FactoryBean来创建bean对象
		前面我们学过了BeanFactory接口，BeanFactory是spring容器的顶层接口，而这里要说的是FactoryBean，也是一个接口，
		这两个接口很容易搞混淆，FactoryBean可以让spring容器通过这个接口的实现来创建我们需要的bean对象。
Spring系列第6篇：bean作用域scope详解
    应用中，有时候我们需要一个对象在整个应用中只有一个，有些对象希望每次使用的时候都重新创建一个，
	spring对我们这种需求也提供了支持，在spring中这个叫做bean的作用域，xml中定义bean的时候，可以通过scope属性指定bean的作用域
	<bean id="" class="" scope="作用域" /> 
	singleton
	当scope的值设置为singleton的时候，整个spring容器中只会存在一个bean实例，
	通过容器多次查找bean的时候（调用BeanFactory的getBean方法或者bean之间注入依赖的bean对象的时候），
	返回的都是同一个bean对象，singleton是scope的默认值，所以spring容器中默认创建的bean对象是单例的，
	通常spring容器在启动的时候，会将scope为singleton的bean创建好放在容器中
	（有个特殊的情况，当bean的lazy被设置为true的时候，表示懒加载，那么使用的时候才会创建），用的时候直接返回。
	单例bean使用注意
	单例bean是整个应用共享的，所以需要考虑到线程安全问题，之前在玩springmvc的时候，springmvc中controller默认是单例的，
	有些开发者在controller中创建了一些变量，那么这些变量实际上就变成共享的了，
	controller可能会被很多线程同时访问，这些线程并发去修改controller中的共享变量，可能会出现数据错乱的问题；所以使用的时候需要特别注意。
	prototype
	如果scope被设置为prototype类型的了，表示这个bean是多例的，通过容器每次获取的bean都是不同的实例，每次获取都会重新创建一个bean实例对象。
	多例bean使用注意
	多例bean每次获取的时候都会重新创建，如果这个bean比较复杂，创建时间比较长，会影响系统的性能，这个地方需要注意。
    下面要介绍的3个：request、session、application都是在spring web容器环境中才会有的
	request
	当一个bean的作用域为request，表示在一次http请求中，一个bean对应一个实例；
	对每个http请求都会创建一个bean实例，request结束的时候，这个bean也就结束了，
	request作用域用在spring容器的web环境中，这个以后讲springmvc的时候会说，
	spring中有个web容器接口WebApplicationContext，这个里面对request作用域提供了支持
	session
	这个和request类似，也是用在web环境中，session级别共享的bean，每个会话会对应一个bean实例，
	不同的session对应不同的bean实例，springmvc中我们再细说
	application
	全局web应用级别的作用于，也是在web环境中使用的，一个web应用程序对应一个bean实例，
	通常情况下和singleton效果类似的，不过也有不一样的地方，singleton是每个spring容器中只有一个bean实例，
	一般我们的程序只有一个spring容器，但是，一个应用程序中可以创建多个spring容器，
	不同的容器中可以存在同名的bean，但是sope=aplication的时候，
	不管应用中有多少个spring容器，这个应用中同名的bean只有一个。
	自定义scope
    有时候，spring内置的几种sope都无法满足我们的需求的时候，我们可以自定义bean的作用域
总结
	1.	spring容器自带的有2种作用域，分别是singleton和prototype；还有3种分别是spring web容器环境中才支持的request、session、application
	2.	singleton是spring容器默认的作用域，一个spring容器中同名的bean实例只有一个，多次获取得到的是同一个bean；单例的bean需要考虑线程安全问题
	3.	prototype是多例的，每次从容器中获取同名的bean，都会重新创建一个；多例bean使用的时候需要考虑创建bean对性能的影响
	4.	一个应用中可以有多个spring容器
	5.	自定义scope 3个步骤，实现Scope接口，将实现类注册到spring容器，使用自定义的sope
Spring系列第7篇：依赖注入之手动注入
    spring依赖注入
	spring中依赖注入主要分为手动注入和自动注入，本文我们主要说一下手动注入，手动注入需要我们明确配置需要注入的对象
	将被依赖方注入到依赖方，通常有2种方式：构造函数的方式和set属性的方式，spring中也是通过这两种方式实现注入的
	通过构造器注入
	构造器的参数就是被依赖的对象，构造器注入又分为3种注入方式：
	•	根据构造器参数索引注入
	•	根据构造器参数类型注入
	•	根据构造器参数名称注入
	根据构造器参数索引注入
	用法
	<bean id="diByConstructorParamIndex" class="com.javacode2018.lesson001.demo5.UserModel">
		<constructor-arg index="0" value="马士兵老师"/>
		<constructor-arg index="1" value="上海市"/>
	</bean>
	constructor-arg用户指定构造器的参数
	index：构造器参数的位置，从0开始
	value：构造器参数的值，value只能用来给简单的类型设置值，
	value对应的属性类型只能为byte,int,long,float,double,boolean,Byte,Long,Float,Double,枚举，
	spring容器内部注入的时候会将value的值转换为对应的类型。
	优缺点
	参数位置的注入对参数顺序有很强的依赖性，若构造函数参数位置被人调整过，会导致注入出错。
	不过通常情况下，不建议去在代码中修改构造函数，如果需要新增参数的，可以新增一个构造函数来实现，这算是一种扩展，不会影响目前已有的功能。
	根据构造器参数类型注入
	用法
	<bean id="diByConstructorParamType" class="com.javacode2018.lesson001.demo5.UserModel">
		<constructor-arg type="参数类型" value="参数值"/>
		<constructor-arg type="参数类型" value="参数值"/>
	</bean>
	constructor-arg用户指定构造器的参数
	type：构造函数参数的完整类型，如：java.lang.String,int,double
	value：构造器参数的值，value只能用来给简单的类型设置值
	优缺点
	实际上按照参数位置或者按照参数的类型注入，都有一个问题，很难通过bean的配置文件，
	知道这个参数是对应UserModel中的那个属性的，代码的可读性不好，
	比如我想知道这每个参数对应UserModel中的那个属性，必须要去看UserModel的源码
	根据构造器参数名称注入
	用法
	<bean id="diByConstructorParamName" class="com.javacode2018.lesson001.demo5.UserModel">
		<constructor-arg name="参数类型" value="参数值"/>
		<constructor-arg name="参数类型" value="参数值"/>
	</bean>
	constructor-arg用户指定构造器的参数
	name：构造参数名称
	value：构造器参数的值，value只能用来给简单的类型设置值
	关于方法参数名称的问题
	java通过反射的方式可以获取到方法的参数名称，不过源码中的参数通过编译之后会变成class对象，
	通常情况下源码变成class文件之后，参数的真实名称会丢失，参数的名称会变成arg0,arg1,arg2这样的，
	和实际参数名称不一样了，如果需要将源码中的参数名称保留在编译之后的class文件中，编译的时候需要用下面的命令：
	javac -parameters java源码
	但是我们难以保证编译代码的时候，操作人员一定会带上-parameters参数，
	所以方法的参数可能在class文件中会丢失，导致反射获取到的参数名称和实际参数名称不符，这个我们需要先了解一下。
	参数名称可能不稳定的问题，spring提供了解决方案，通过ConstructorProperties注解来定义参数的名称，将这个注解加在构造方法上面
	setter注入
	通常情况下，我们的类都是标准的javabean，javabean类的特点：
	•	属性都是private访问级别的
	•	属性通常情况下通过一组setter（修改器）和getter（访问器）方法来访问
	•	setter方法，以set 开头，后跟首字母大写的属性名，如：setUserName，简单属性一般只有一个方法参数，方法返回值通常为void;
	•	getter方法，一般属性以get开头，对于boolean类型一般以is开头，后跟首字母大写的属性名，如：getUserName，isOk；
	spring对符合javabean特点类，提供了setter方式的注入，会调用对应属性的setter方法将被依赖的对象注入进去。
	用法
	<bean id="" class="">
		<property name="属性名称" value="属性值" />
		...
		<property name="属性名称" value="属性值" />
	</bean>
	property用于对属性的值进行配置，可以有多个
	name：属性的名称
	value：属性的值
	优缺点
	setter注入相对于构造函数注入要灵活一些，构造函数需要指定对应构造函数中所有参数的值，
	而setter注入的方式没有这种限制，不需要对所有属性都进行注入，可以按需进行注入。
	上面介绍的都是注入普通类型的对象，都是通过value属性来设置需要注入的对象的值的，
	value属性的值是String类型的，spring容器内部自动会将value的值转换为对象的实际类型。
	若我们依赖的对象是容器中的其他bean对象的时候，需要用下面的方式进行注入
	注入容器中的bean
	注入容器中的bean有两种写法：
	•	ref属性方式
	•	内置bean的方式
	ref属性方式
	将上面介绍的constructor-arg或者property元素的value属性名称替换为ref，ref属性的值为容器中其他bean的名称，如：
	构造器方式，将value替换为ref：
	<constructor-arg ref="需要注入的bean的名称"/>
	setter方式，将value替换为ref：
	<property name="属性名称" ref="需要注入的bean的名称" />
	内置bean的方式
	构造器的方式：
	<constructor-arg>
		<bean class=""/>
	</constructor-arg>
	setter方式：
	<property name="属性名称">
		<bean class=""/>
	</property>
	其他类型注入
	注入java.util.List（list元素）
	<list>
		<value>Spring</value>
		或
		<ref bean="bean名称"/>
		或
		<list></list>
		或
		<bean></bean>
		或
		<array></array>
		或
		<map></map>
	</list>
	注入java.util.Set（set元素）
	<set>
		<value>Spring</value>
		或
		<ref bean="bean名称"/>
		或
		<list></list>
		或
		<bean></bean>
		或
		<array></array>
		或
		<map></map>
	</set>
	注入java.util.Map（map元素）
	<map>
		<entry key="马士兵老师" value="30" key-ref="key引用的bean名称" value-ref="value引用的bean名称"/>
		或
		<entry>
			<key>
				value对应的值，可以为任意类型
			</key>
			<value>
				value对应的值，可以为任意类型
			</value>
		</entry>
	</map>
	注入数组（array元素）
	<array>
		数组中的元素
	</array>
	注入java.util.Properties（props元素）
	Properties类相当于键值都是String类型的Map对象，使用props进行注入，如下：
	<props>
		<prop key="key1">java高并发系列</prop>
		<prop key="key2">mybatis系列</prop>
		<prop key="key3">mysql系列</prop>
	</props>
	总结
	1.	本文主要讲解了xml中bean的依赖注入，都是采用硬编码的方式进行注入的，这种算是手动的方式
	2.	注入普通类型通过value属性或者value元素设置注入的值；注入对象如果是容器的其他bean的时候，需要使用ref属性或者ref元素或者内置bean元素的方式
	3.	还介绍了其他几种类型List、Set、Map、数组、Properties类型的注入，多看几遍加深理解
	4.	后面我们将介绍spring为我们提供的更牛逼的自动注入
Spring系列第8篇：依赖注入之自动注入（autowire）详解
	手动注入的不足
	上篇文章中介绍了依赖注入中的手动注入，所谓手动注入是指在xml中采用硬编码的方式来配置注入的对象，
	比如通过构造器注入或者set方法注入，这些注入的方式都存在不足
	自动注入
	自动注入是采用约定大约配置的方式来实现的，程序和spring容器之间约定好，遵守某一种都认同的规则，来实现自动注入。
	xml中可以在bean元素中通过autowire属性来设置自动注入的方式：
	<bean id="" class="" autowire="byType|byName|constructor|default" />
	•	byteName：按照名称进行注入
	•	byType：按类型进行注入
	•	constructor：按照构造方法进行注入
	•	default：默认注入方式
	按照名称进行注入（byName）
	用法
	autowire设置为byName
	<bean id="" class="X类" autowire="byName"/>
	spring容器会按照set属性的名称去容器中查找同名的bean对象，然后将查找到的对象通过set方法注入到对应的bean中，未找到对应名称的bean对象则set方法不进行注入
	需要注入的set属性的名称和被注入的bean的名称必须一致。
	优缺点
	按名称进行注入的时候，要求名称和set属性的名称必须同名，相对于硬编码的方式注入，确实节省了不少代码。
	按照类型进行自动注入
	用法
	autowire设置为byType
	<bean id="" class="X类" autowire="byType"/>
	spring容器会遍历x类中所有的set方法，会在容器中查找和set参数类型相同的bean对象，
	将其通过set方法进行注入，未找到对应类型的bean对象则set方法不进行注入。
	需要注入的set属性的类型和被注入的bean的类型需要满足isAssignableFrom关系。
	按照类型自动装配的时候，如果按照类型找到了多个符合条件的bean，系统会报错。
	set方法的参数如果是下面的类型或者下面类型的数组的时候，这个set方法会被跳过注入：
	Object,Boolean,boolean,Byte,byte,Character,char,Double,double,Float,float,Integer,int,Long,
	Short,shot,Enum,CharSequence,Number,Date,java.time.temporal.Temporal,java.net.URI,java.net.URI,
	java.util.Locale,java.lang.Class
	优缺点
	相对于手动注入，节省了不少代码，新增或者删除属性，只需要增减对应的set方法就可以了，更容易扩展了。
	注入类型匹配的所有bean(重点)
	按照类型注入还有2中比较牛逼的用法
	•	一个容器中满足某种类型的bean可以有很多个，将容器中某种类型中的所有bean，
	通过set方法注入给一个java.util.List<需要注入的Bean的类型或者其父类型或者其接口>对象
	•	将容器中某种类型中的所有bean，通过set方法注入给一个java.util.Map<String,需要注入的Bean的类型或者其父类型或者其接口>对象
	按照构造函数进行自动注入
	用法
	autowire设置为constructor
	<bean id="" class="X类" autowire="constructor"/>
	spring会找到x类中所有的构造方法（一个类可能有多个构造方法），然后将这些构造方法进行排序
	（先按修饰符进行排序，public的在前面，其他的在后面，如果修饰符一样的，会按照构造函数参数数量倒叙，
	也就是采用贪婪的模式进行匹配，spring容器会尽量多注入一些需要的对象）得到一个构造函数列表，会轮询这个构造器列表，
	判断当前构造器所有参数是否在容器中都可以找到匹配的bean对象，如果可以找到就使用这个构造器进行注入，
	如果不能找到，那么就会跳过这个构造器，继续采用同样的方式匹配下一个构造器，直到找到一个合适的为止。	
	autowire=default
	用法
	bean xml的根元素为beans，注意根元素有个default-autowire属性，
	这个属性可选值有(no|byName|byType|constructor|default)，
	这个属性可以批量设置当前文件中所有bean的自动注入的方式，
	bean元素中如果省略了autowire属性，那么会取default-autowire的值作为其autowire的值，
	而每个bean元素还可以单独设置自己的autowire覆盖default-autowire的配置
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		   xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"
		   default-autowire="byName">

	</beans>
	总结
	•	xml中手动注入存在的不足之处，可以通过自动注入的方式来解决，本文介绍了3中自动注入：
	通过名称自动注入、通过类型自动注入、通过构造器自动注入
	•	按类型注入中有个比较重要的是注入匹配类型所有的bean，可以将某种类型所有的bean注入给一个List对象，
	可以将某种类型的所有bean按照bean名称->bean对象的映射方式注入给一个Map对象，这种用法比较重要，用途比较大，要掌握
	•	spring中还有其他自动注入的方式，用起来会更爽，后面的文章中我们会详细介绍。
Spring系列第9篇：depend-on干什么的
	1.	bean对象的创建顺序和bean xml中定义的顺序一致
	2.	bean销毁的顺序和bean xml中定义的顺序相反
	1.	bean对象的创建顺序和bean依赖的顺序一致
	2.	bean销毁的顺序和bean创建的顺序相反
	通过depend-on干预bean创建和销毁顺序
	上面看到了对于无依赖的bean，通过定义的顺序确实可以干预bean的创建顺序，通过强依赖也可以干预bean的创建顺序。
	那么如果xml中定义的bean特别多，而有些bean之间也没有强依赖关系，此时如果想去调整bean的创建和销毁的顺序，
	得去调整xml中bean的定义顺序，或者去加强依赖，这样是非常不好的，spring中可以通过depend-on来解决这些问题，
	在不调整bean的定义顺序和强加依赖的情况下，可以通过通过depend-on属性来设置当前bean的依赖于哪些bean，
	那么可以保证depend-on指定的bean在当前bean之前先创建好，销毁的时候在当前bean之后进行销毁。
	depend-on使用方式：
	<bean id="bean1" class="" depend-on="bean2,bean3; bean4" />
	depend-on：设置当前bean依赖的bean名称，可以指定多个，多个之间可以用”,;空格“进行分割
	上面不管bean2,bean2,bean4在任何地方定义，都可以确保在bean1创建之前，会先将bean2,bean3,bean4创建好，
	表示bean1依赖于这3个bean，可能bean1需要用到bean2、bean3、bean4中生成的一些资源或者其他的功能等，
	但是又没有强制去在bean1类中通过属性定义强依赖的方式去依赖于bean2、bean3、bean4；
	当然销毁的时候也会先销毁当前bean，再去销毁被依赖的bean，即先销毁bean1，再去销毁depend-on指定的bean
	1.	无依赖的bean创建顺序和定义的顺序一致，销毁顺序刚好相反
	2.	通过构造器强依赖的bean，会先创建构造器参数中对应的bean，然后才会创建当前bean，销毁顺序刚好相反
	3.	depend-on可以指定档期bean依赖的bean，通过这个可以确保depend-on指定的bean在当前bean创建之前先创建好，销毁顺序刚好相反
Spring系列第10篇：primary可以解决什么问题
	org.springframework.beans.factory.NoUniqueBeanDefinitionException
	当希望从容器中获取到一个bean对象的时候，容器中却找到了多个匹配的bean，此时spring不知道如何选择了，处于懵逼状态，就会报这个异常。
	spring中可以通过bean元素的primary属性来解决这个问题，可以通过这个属性来指定当前bean为主要候选者，
	当容器查询一个bean的时候，如果容器中有多个候选者匹配的时候，此时spring会返回主要的候选者。
	我们将serviceA的primary属性置为true了，将其置为主要候选者，容器中如果查找bean的时候，如果有多个匹配的，就以他为主。
	候选者中如果有多个bean都将primary置为true，此时spring还是会懵逼的，也会报错，不知道如何选择了。
	总结
	当从容器中查找一个bean的时候，如果容器中出现多个Bean候选者时，
	可以通过primary="true"将当前bean置为首选者，那么查找的时候就会返回主要的候选者，否则将抛出异常。
Spring系列第11篇：bean中的autowire-candidate属性又是干什么的
	spring还有一种方法也可以解决这个问题，可以设置某个bean是否在自动注入的时候是否为作为候选bean，通过bean元素的autowire-candidate属性类配置，如下：
	<bean id="serviceA" class="com.javacode2018.lesson001.demo8.SetterBean$ServiceA" autowire-candidate="false"/>
	autowire-candidate：设置当前bean在被其他对象作为自动注入对象的时候，是否作为候选bean，默认值是true。
	autowire-candidates属性解析源码
	beans元素是xml中定义bean的根元素，beans元素有个default-autowire-candidates属性，
	用于定义哪些bean可以作为候选者，default-autowire-candidates的值是个通配符如：
	default-autowire-candidates="*Service"
	再来说一下bean元素的autowire-candidate属性，这个属性有3个可选值：
	•	default：这个是默认值，autowire-candidate如果不设置，其值就是default
	•	true：作为候选者
	•	false：不作为候选者
Spring系列第12篇：lazy-init：bean延迟初始化
	bean初始化的2种方式
	1.	实时初始化
	2.	延迟初始化
	bean实时初始化
	在容器启动过程中被创建组装好的bean，称为实时初始化的bean，
	spring中默认定义的bean都是实时初始化的bean，这些bean默认都是单例的，在容器启动过程中会被创建好，然后放在spring容器中以供使用。
	实时初始化bean的有一些优点
	1.	更早发下bean定义的错误：实时初始化的bean如果定义有问题，会在容器启动过程中会抛出异常，让开发者快速发现问题
	2.	查找bean更快：容器启动完毕之后，实时初始化的bean已经完全创建好了，
	此时被缓存在spring容器中，当我们需要使用的时候，容器直接返回就可以了，速度是非常快的
	延迟初始化的bean
	从上面我们可以看出，实时初始化的bean都会在容器启动过程中创建好，如果程序中定义的bean非常多，
	并且有些bean创建的过程中比较耗时的时候，会导致系统消耗的资源比较多，并且会让整个启动时间比较长，
	这个我估计大家都是有感受的，使用spring开发的系统比较大的时候，整个系统启动耗时是比较长的，基本上多数时间都是在创建和组装bean。
	spring对这些问题也提供了解决方案：bean延迟初始化。
	所谓延迟初始化，就是和实时初始化刚好相反，延迟初始化的bean在容器启动过程中不会创建，而是需要使用的时候才会去创建，
	先说一下bean什么时候会被使用：
	1.	被其他bean作为依赖进行注入的时候，比如通过property元素的ref属性进行引用，通过构造器注入、
	通过set注入、通过自动注入，这些都会导致被依赖bean的创建
	2.	开发者自己写代码向容器中查找bean的时候，如调用容器的getBean方法获取bean。
	延迟bean的配置
	在bean定义的时候通过lazy-init属性来配置bean是否是延迟加载，true：延迟初始化，false：实时初始化
	<bean lazy-init="是否是延迟初始化" />
	总结
	延迟初始化的bean无法在程序启动过程中迅速发现bean定义的问题，
	第一次获取的时候可能耗时会比较长。在实际工作中用的比较少，作为了解，以后碰到的时候会有个印象。
Spring系列第13篇：使用继承简化bean配置(abstract & parent)
	上面多了一个baseService的bean，这个bean没有指定class对象，但是多了一个abstract="true"的属性，
	表示这个bean是抽象的，abstract为true的bean在spring容器中不会被创建，只是会将其当做bean定义的模板，
	而serviceB和serviceC的定义中多了一个属性parent，用来指定当前bean的父bean名称，此处是baseService，
	此时serviceB和serviceC会继承baseService中定义的配置信息。
	子bean中也可以重新定义父bean中已经定义好的配置，这样子配置会覆盖父bean中的配置信息
	总结
	1.	bean元素的abstract属性为true的时候可以定义某个bean为一个抽象的bean，相当于定义了一个bean模板，
	spring容器并不会创建这个bean，从容器中查找abstract为true的bean的时候，会报错BeanIsAbstractException异常
	2.	bean元素的parent属性可以指定当前bean的父bean，子bean可以继承父bean中配置信息，
	也可以自定义配置信息，这样可以覆盖父bean中的配置
Spring系列第14篇：lookup-method和replaced-method
	lookup-method：方法查找
	通常情况下，我们使用的bean都是单例的，如果一个bean需要依赖于另一个bean的时候，
	可以在当前bean中声明另外一个bean引用，然后注入依赖的bean，此时被依赖的bean在当前bean中自始至终都是同一个实例。
	单例bean中使用多例bean：lookup-method方式实现
	上面这种方式实现了单例bean中使用多例bean的需求，但是用到spring中的接口ApplicationContextAware，
	此时对spring的api有耦合的作用，我们一直推行高内聚低耦合，所以我们得寻求更好的办法。
	能不能有这样的功能，当serviceB中调用getServiceA的时候，系统自动将这个方法拦截，
	然后去spring容器中查找对应的serviceA对象然后返回，spring中的lookup-method就可以实现这样的功能。
	lookup-method：看其名字，就知道意思：方法查找，调用name属性指定的方法的时候，spring会对这个方法进行拦截，
	然后去容器中查找lookup-method元素中bean属性指定的bean，然后将找到的bean作为方法的返回值返回。这个地方底层是使用cglib代理实现的
	replaced-method：方法替换
	replaced-method：方法替换，比如我们要调用serviceB中的getServiceA的时候，
	我们可以对serviceB这个bean中的getServiceA方法进行拦截，把这个调用请求转发到一个替换者处理。
	这就是replaced-method可以实现的功能，比lookup-method更强大更灵活。
	总结
	1.	lookup-method：方法查找，可以对指定的bean的方法进行拦截，然后从容器中查找指定的bean作为被拦截方法的返回值
	2.	replaced-method：方法替换，可以实现bean方法替换的效果，整体来说比lookup-method更灵活一些
	3.	单例bean中使用多例bean，本文中列出了3种方式，
Spring系列第15篇：代理详解（java动态代理&CGLIB代理)
	代理spring中用到的挺多的，比如上篇文章中的lookup-method和replaced-method，以及后面我们要学的aop、spring中的事务、
	spring中解析@configuration注解等等，这些都是依靠代理来实现的
	通用代理的2种实现：
	1.	jdk动态代理
	2.	cglib代理

	jdk动态代理详解
	jdk中为实现代理提供了支持，主要用到2个类：
	java.lang.reflect.Proxy
	java.lang.reflect.InvocationHandler
	jdk自带的代理使用上面有个限制，只能为接口创建代理类，如果需要给具体的类创建代理类，需要用后面要说的cglib
	getProxyClass方法
	为指定的接口创建代理类，返回代理类的Class对象
	public static Class<?> getProxyClass(ClassLoader loader,
											 Class<?>... interfaces)
	参数说明：
	loader：定义代理类的类加载器
	interfaces：指定需要实现的接口列表，创建的代理默认会按顺序实现interfaces指定的接口
	newProxyInstance方法
	创建代理类的实例对象
	public static Object newProxyInstance(ClassLoader loader,
											  Class<?>[] interfaces,
											  InvocationHandler h)
	这个方法先为指定的接口创建代理类，然后会生成代理类的一个实例，最后一个参数比较特殊，是InvocationHandler类型的，这个是个接口如下：
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable;
	上面方法会返回一个代理对象，当调用代理对象的任何方法的时候，会就被InvocationHandler接口的invoke方法处理，
	所以主要代码需要卸载invoke方法中，稍后会有案例细说。
	isProxy方法
	判断指定的类是否是一个代理类
	public static boolean isProxyClass(Class<?> cl)
	getInvocationHandler方法
	获取代理对象的InvocationHandler对象
	public static InvocationHandler getInvocationHandler(Object proxy)
			throws IllegalArgumentException
	Proxy使用注意
	1.	jdk中的Proxy只能为接口生成代理类，如果你想给某个类创建代理类，那么Proxy是无能为力的，此时需要我们用到下面要说的cglib了。
	2.	Proxy类中提供的几个常用的静态方法大家需要掌握
	3.	通过Proxy创建代理对象，当调用代理对象任意方法时候，会被InvocationHandler接口中的invoke方法进行处理，这个接口内容是关键
	cglib代理详解
	什么是cglib
	jdk动态代理只能为接口创建代理，使用上有局限性。实际的场景中我们的类不一定有接口，
	此时如果我们想为普通的类也实现代理功能，我们就需要用到cglib来实现了。
	cglib是一个强大、高性能的字节码生成库，它用于在运行时扩展Java类和实现接口；
	本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法）。
	Enhancer可能是CGLIB中最常用的一个类，和jdk中的Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。
	Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。
	Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。
	基于同样的道理，Enhancer也不能对final类进行代理操作。
	CGLIB作为一个开源项目，其代码托管在github，地址为：
	https://github.com/cglib/cglib
	CGLIB底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类。
	除了CGLIB库外，脚本语言（如Groovy和BeanShell）也使用ASM生成字节码。
	ASM使用类似SAX的解析器来实现高性能。我们不鼓励直接使用ASM，因为它需要对Java字节码的格式足够的了解。
	spring已将第三方cglib jar包中所有的类集成到spring自己的jar包中，
	本系列内容都是和spring相关的，为了方便，我们直接使用spring内部已集成的来讲解
	上面代码中的注释很详细，列出了给指定的类创建代理的具体步骤，整个过程中主要用到了Enhancer类和MethodInterceptor接口。
	enhancer.setSuperclass用来设置代理类的父类，即需要给哪个类创建代理类，此处是Service1
	enhancer.setCallback传递的是MethodInterceptor接口类型的参数，MethodInterceptor接口有个intercept方法，
	这个方法会拦截代理对象所有的方法调用。
	还有一个重点是Object result = methodProxy.invokeSuper(o, objects);可以调用被代理类，
	也就是Service1类中的具体的方法，从方法名称的意思可以看出是调用父类，实际对某个类创建代理，
	cglib底层通过修改字节码的方式为Service1类创建了一个子类。
	CGLIB和Java动态代理的区别
	1.	Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，
	Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
	2.	Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；
	CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效































	






	







	







	




































