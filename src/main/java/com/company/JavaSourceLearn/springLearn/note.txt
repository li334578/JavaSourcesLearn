spring是一个简化java企业级开发的一个框架，内部包含了很多技术。
比如：控制反转&依赖注入、面向切面编程、spring事务管理、
通过spring集成其他框架、springmvc、springboot、springcloud等等
spring容器
    spring容器的概念，容器这个名字起的相当好，容器可以放很多东西，
	我们的程序启动的时候会创建spring容器，会给spring容器一个清单，清单中列出了需要创建的对象以及对象依赖关系，
	spring容器会创建和组装好清单中的对象，然后将这些对象存放在spring容器中，当程序中需要使用的时候，可以到容器中查找获取，然后直接使用。
IOC：控制反转
    使用者之前使用B对象的时候都需要自己去创建和组装，而现在这些创建和组装都交给spring容器去给完成了，
	使用者只需要去spring容器中查找需要使用的对象就可以了；
	这个过程中B对象的创建和组装过程被反转了，之前是使用者自己主动去控制的，
	现在交给spring容器去创建和组装了，对象的构建过程被反转了，所以叫做控制反转；
	IOC是是面相对象编程中的一种设计原则，主要是为了降低系统代码的耦合度，让系统利于维护和扩展。
DI：依赖注入
    依赖注入是spring容器中创建对象时给其设置依赖对象的方式，比如给spring一个清单，
	清单中列出了需要创建B对象以及其他的一些对象（可能包含了B类型中需要依赖对象），
	此时spring在创建B对象的时候，会看B对象需要依赖于哪些对象，然后去查找一下清单中有没有包含这些被依赖的对象，
	如果有就去将其创建好，然后将其传递给B对象；
	可能B需要依赖于很多对象，B创建之前完全不需要知道其他对象是否存在或者其他对象在哪里以及被他们是如何创建，
	而spring容器会将B依赖对象主动创建好并将其注入到B中去，
	比如spring容器创建B的时候，发现B需要依赖于A，那么spring容器在清单中找到A的定义并将其创建好之后，注入到B对象中。
总结
	1.	IOC控制反转，是一种设计理念，将对象创建和组装的主动控制权利交给了spring容器去做，
	控制的动作被反转了，降低了系统的耦合度，利于系统维护和扩展，
	主要就是指需要使用的对象的组装控制权被反转了，之前是自己要做的，现在交给spring容器做了。
	2.	DI依赖注入，表示spring容器中创建对象时给其设置依赖对象的方式，
	通过某些注入方式可以让系统更灵活，比如自动注入等可以让系统变的很灵活。
	3.	spring容器：主要负责容器中对象的创建、组装、对象查找、对象生命周期的管理等等操作。
IOC容器
	IOC容器是具有依赖注入功能的容器，负责对象的实例化、对象的初始化，对象和对象之间依赖关系配置、对象的销毁、对外提供对象的查找等操作，
	对象的整个生命周期都是由容器来控制。
	我们需要使用的对象都由ioc容器进行管理，不需要我们再去手动通过new的方式去创建对象，
	由ioc容器直接帮我们组装好，当我们需要使用的时候直接从ioc容器中直接获取就可以了。

Bean概念
	由spring容器管理的对象统称为Bean对象。
	Bean就是普通的java对象，和我们自己new的对象其实是一样的，
	只是这些对象是由spring去创建和管理的，我们需要在配置文件中告诉spring容器需要创建哪些bean对象，
	所以需要先在配置文件中定义好需要创建的bean对象，这些配置统称为bean定义配置元数据信息，
	spring容器通过读取这些bean配置元数据信息来构建和组装我们需要的对象。
BeanFactory接口
	org.springframework.beans.factory.BeanFactory
	spring容器中具有代表性的容器就是BeanFactory接口，这个是spring容器的顶层接口，提供了容器最基本的功能。
    常用的几个方法
		//按bean的id或者别名查找容器中的bean
		Object getBean(String name) throws BeansException

		//这个是一个泛型方法，按照bean的id或者别名查找指定类型的bean，返回指定类型的bean对象
		<T> T getBean(String name, Class<T> requiredType) throws BeansException;

		//返回容器中指定类型的bean对象
		<T> T getBean(Class<T> requiredType) throws BeansException;

		//获取指定类型bean对象的获取器，这个方法比较特别，以后会专门来讲
		<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
ApplicationContext接口
	org.springframework.context.ApplicationContext
	这个接口继承了BeanFactory接口，所以内部包含了BeanFactory所有的功能，
	并且在其上进行了扩展，增加了很多企业级功能，比如AOP、国际化、事件支持等等。
ClassPathXmlApplicationContext类
	org.springframework.context.support.ClassPathXmlApplicationContext
	这个类实现了ApplicationContext接口，注意一下这个类名称包含了ClassPath Xml，
	说明这个容器类可以从classpath中加载bean xml配置文件，然后创建xml中配置的bean对象，一会后面的案例就会用到这个类。
AnnotationConfigApplicationContext类
	org.springframework.context.annotation.AnnotationConfigApplicationContext
	这个类也实现了ApplicationContext接口，注意其类名包含了Annotation和config两个单词，上面我们有说过，
	bean的定义支持xml的方式和注解的方式，当我们使用注解的方式定义bean的时候，就需要用到这个容器来装载了，
	这个容器内部会解析注解来构建构建和管理需要的bean。
	注解的方式相对于xml方式更方便一些，也是我们比较推荐的方式，后面我们会大量使用这种方式，具体会详解。
bean xml配置文件格式
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		   xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
		
		<import resource="引入其他bean xml配置文件" />
		<bean id="bean标识" class="玩转类型名称"/>
		<alias name="bean标识" alias="别名" />

	</beans>
    beans是根元素，下面可以包含任意数量的import、bean、alias元素，下面我们对每个元素进行详解。
	bean元素
	用来定义一个bean对象。
	格式
	<bean id="bean唯一标识" name="bean名称" class="完整类型名称" factory-bean="工厂bean名称" factory-method="工厂方法"/>
	bean名称
	每个bean都有一个名称，叫做bean名称，bean名称在一个spring容器中必须唯一，否则会报错，通过bean名称可以从spring容器获取对应的bean对象。
	bean别名
	相当于人的外号一样，一个人可能有很多外号，当别人喊这个人的名称或者外号的时候，都可以找到这个人。
	那么bean也一样，也可以给bean起几个外号，这个外号在spring中叫做bean的别名，spring容器允许使用者通过名称或者别名获取对应的bean对象。
	bean名称别名定义规则
	名称和别名可以通过bean元素中的id和name来定义，具体定义规则如下：：
	1.	当id存在的时候，不管name有没有，取id为bean的名称
	2.	当id不存在，此时需要看name，name的值可以通过,;或者空格分割，
	最后会按照分隔符得到一个String数组，数组的第一个元素作为bean的名称，其他的作为bean的别名
	3.	当id和name都存在的时候，id为bean名称，name用来定义多个别名
	4.	当id和name都不指定的时候，bean名称自动生成，生成规则下面详细说明
	id和name都未指定
	bean的class的完整类名#编号
	上面的编号是从0开始的，同种类型的没有指定名称的依次递增。
	第一个会有别名，别名为完整的类名。bean名称为完整类名#编号。
	alias元素
	alias元素也可以用来给某个bean定义别名，语法：
	<alias name="需要定义别名的bean" alias="别名" />
	import元素
	当我们的系统比较大的时候，会分成很多模块，每个模块会对应一个bean xml文件，我们可以在一个总的bean xml中对其他bean xml进行汇总，
	相当于把多个bean xml的内容合并到一个里面了，可以通过import元素引入其他bean配置文件。
	<import resource="其他配置文件的位置" />
容器创建bean实例有多少种
	Spring容器内部创建bean实例对象常见的有4种方式。
	    通过反射调用构造方法创建bean对象
		  调用类的构造方法获取对应的bean实例，是使用最多的方式，这种方式只需要在xml bean元素中指定class属性，
		spring容器内部会自动调用该类型的构造方法来创建bean对象，将其放在容器中以供使用。
		语法
		<bean id="bean名称" name="bean名称或者别名" class="bean的完整类型名称">
			<constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
			....
			<constructor-arg index="n" value="bean的值" ref="引用的bean名称" />
		</bean>
			constructor-arg用于指定构造方法参数的值
			index：构造方法中参数的位置，从0开始，依次递增
			value：指定参数的值
			ref：当插入的值为容器内其他bean的时候，这个值为容器中对应bean的名称
		通过静态工厂方法创建bean对象
		语法
		<bean id="bean名称" name="" class="静态工厂完整类名" factory-method="静态工厂的方法">
			<constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
			....
			<constructor-arg index="n" value="bean的值" ref="引用的bean名称" />
		</bean>
		class：指定静态工厂完整的类名
		factory-method：静态工厂中的静态方法，返回需要的对象。
		constructor-arg用于指定静态方法参数的值，用法和上面介绍的构造方法一样。
		spring容器会自动调用静态工厂的静态方法获取指定的对象，将其放在容器中以供使用
		通过实例工厂方法创建bean对象
		让spring容器去调用某些对象的某些实例方法来生成bean对象放在容器中以供使用。
		语法
		<bean id="bean名称" factory-bean="需要调用的实例对象bean名称" factory-method="bean对象中的方法">
			<constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
			....
			<constructor-arg index="n" value="bean的值" ref="引用的bean名称" />
		</bean>
		spring容器以factory-bean的值为bean名称查找对应的bean对象，然后调用该对象中factory-method属性值指定的方法，
		将这个方法返回的对象作为当前bean对象放在容器中供使用。
		通过FactoryBean来创建bean对象
		前面我们学过了BeanFactory接口，BeanFactory是spring容器的顶层接口，而这里要说的是FactoryBean，也是一个接口，
		这两个接口很容易搞混淆，FactoryBean可以让spring容器通过这个接口的实现来创建我们需要的bean对象。
Spring系列第6篇：bean作用域scope详解
    应用中，有时候我们需要一个对象在整个应用中只有一个，有些对象希望每次使用的时候都重新创建一个，
	spring对我们这种需求也提供了支持，在spring中这个叫做bean的作用域，xml中定义bean的时候，可以通过scope属性指定bean的作用域
	<bean id="" class="" scope="作用域" /> 
	singleton
	当scope的值设置为singleton的时候，整个spring容器中只会存在一个bean实例，
	通过容器多次查找bean的时候（调用BeanFactory的getBean方法或者bean之间注入依赖的bean对象的时候），
	返回的都是同一个bean对象，singleton是scope的默认值，所以spring容器中默认创建的bean对象是单例的，
	通常spring容器在启动的时候，会将scope为singleton的bean创建好放在容器中
	（有个特殊的情况，当bean的lazy被设置为true的时候，表示懒加载，那么使用的时候才会创建），用的时候直接返回。
	单例bean使用注意
	单例bean是整个应用共享的，所以需要考虑到线程安全问题，之前在玩springmvc的时候，springmvc中controller默认是单例的，
	有些开发者在controller中创建了一些变量，那么这些变量实际上就变成共享的了，
	controller可能会被很多线程同时访问，这些线程并发去修改controller中的共享变量，可能会出现数据错乱的问题；所以使用的时候需要特别注意。
	prototype
	如果scope被设置为prototype类型的了，表示这个bean是多例的，通过容器每次获取的bean都是不同的实例，每次获取都会重新创建一个bean实例对象。
	多例bean使用注意
	多例bean每次获取的时候都会重新创建，如果这个bean比较复杂，创建时间比较长，会影响系统的性能，这个地方需要注意。
    下面要介绍的3个：request、session、application都是在spring web容器环境中才会有的
	request
	当一个bean的作用域为request，表示在一次http请求中，一个bean对应一个实例；
	对每个http请求都会创建一个bean实例，request结束的时候，这个bean也就结束了，
	request作用域用在spring容器的web环境中，这个以后讲springmvc的时候会说，
	spring中有个web容器接口WebApplicationContext，这个里面对request作用域提供了支持
	session
	这个和request类似，也是用在web环境中，session级别共享的bean，每个会话会对应一个bean实例，
	不同的session对应不同的bean实例，springmvc中我们再细说
	application
	全局web应用级别的作用于，也是在web环境中使用的，一个web应用程序对应一个bean实例，
	通常情况下和singleton效果类似的，不过也有不一样的地方，singleton是每个spring容器中只有一个bean实例，
	一般我们的程序只有一个spring容器，但是，一个应用程序中可以创建多个spring容器，
	不同的容器中可以存在同名的bean，但是sope=aplication的时候，
	不管应用中有多少个spring容器，这个应用中同名的bean只有一个。
	自定义scope
    有时候，spring内置的几种sope都无法满足我们的需求的时候，我们可以自定义bean的作用域
总结
	1.	spring容器自带的有2种作用域，分别是singleton和prototype；还有3种分别是spring web容器环境中才支持的request、session、application
	2.	singleton是spring容器默认的作用域，一个spring容器中同名的bean实例只有一个，多次获取得到的是同一个bean；单例的bean需要考虑线程安全问题
	3.	prototype是多例的，每次从容器中获取同名的bean，都会重新创建一个；多例bean使用的时候需要考虑创建bean对性能的影响
	4.	一个应用中可以有多个spring容器
	5.	自定义scope 3个步骤，实现Scope接口，将实现类注册到spring容器，使用自定义的sope
Spring系列第7篇：依赖注入之手动注入
    spring依赖注入
	spring中依赖注入主要分为手动注入和自动注入，本文我们主要说一下手动注入，手动注入需要我们明确配置需要注入的对象
	将被依赖方注入到依赖方，通常有2种方式：构造函数的方式和set属性的方式，spring中也是通过这两种方式实现注入的
	通过构造器注入
	构造器的参数就是被依赖的对象，构造器注入又分为3种注入方式：
	•	根据构造器参数索引注入
	•	根据构造器参数类型注入
	•	根据构造器参数名称注入
	根据构造器参数索引注入
	用法
	<bean id="diByConstructorParamIndex" class="com.javacode2018.lesson001.demo5.UserModel">
		<constructor-arg index="0" value="马士兵老师"/>
		<constructor-arg index="1" value="上海市"/>
	</bean>
	constructor-arg用户指定构造器的参数
	index：构造器参数的位置，从0开始
	value：构造器参数的值，value只能用来给简单的类型设置值，
	value对应的属性类型只能为byte,int,long,float,double,boolean,Byte,Long,Float,Double,枚举，
	spring容器内部注入的时候会将value的值转换为对应的类型。
	优缺点
	参数位置的注入对参数顺序有很强的依赖性，若构造函数参数位置被人调整过，会导致注入出错。
	不过通常情况下，不建议去在代码中修改构造函数，如果需要新增参数的，可以新增一个构造函数来实现，这算是一种扩展，不会影响目前已有的功能。
	根据构造器参数类型注入
	用法
	<bean id="diByConstructorParamType" class="com.javacode2018.lesson001.demo5.UserModel">
		<constructor-arg type="参数类型" value="参数值"/>
		<constructor-arg type="参数类型" value="参数值"/>
	</bean>
	constructor-arg用户指定构造器的参数
	type：构造函数参数的完整类型，如：java.lang.String,int,double
	value：构造器参数的值，value只能用来给简单的类型设置值
	优缺点
	实际上按照参数位置或者按照参数的类型注入，都有一个问题，很难通过bean的配置文件，
	知道这个参数是对应UserModel中的那个属性的，代码的可读性不好，
	比如我想知道这每个参数对应UserModel中的那个属性，必须要去看UserModel的源码
	根据构造器参数名称注入
	用法
	<bean id="diByConstructorParamName" class="com.javacode2018.lesson001.demo5.UserModel">
		<constructor-arg name="参数类型" value="参数值"/>
		<constructor-arg name="参数类型" value="参数值"/>
	</bean>
	constructor-arg用户指定构造器的参数
	name：构造参数名称
	value：构造器参数的值，value只能用来给简单的类型设置值
	关于方法参数名称的问题
	java通过反射的方式可以获取到方法的参数名称，不过源码中的参数通过编译之后会变成class对象，
	通常情况下源码变成class文件之后，参数的真实名称会丢失，参数的名称会变成arg0,arg1,arg2这样的，
	和实际参数名称不一样了，如果需要将源码中的参数名称保留在编译之后的class文件中，编译的时候需要用下面的命令：
	javac -parameters java源码
	但是我们难以保证编译代码的时候，操作人员一定会带上-parameters参数，
	所以方法的参数可能在class文件中会丢失，导致反射获取到的参数名称和实际参数名称不符，这个我们需要先了解一下。
	参数名称可能不稳定的问题，spring提供了解决方案，通过ConstructorProperties注解来定义参数的名称，将这个注解加在构造方法上面
	setter注入
	通常情况下，我们的类都是标准的javabean，javabean类的特点：
	•	属性都是private访问级别的
	•	属性通常情况下通过一组setter（修改器）和getter（访问器）方法来访问
	•	setter方法，以set 开头，后跟首字母大写的属性名，如：setUserName，简单属性一般只有一个方法参数，方法返回值通常为void;
	•	getter方法，一般属性以get开头，对于boolean类型一般以is开头，后跟首字母大写的属性名，如：getUserName，isOk；
	spring对符合javabean特点类，提供了setter方式的注入，会调用对应属性的setter方法将被依赖的对象注入进去。
	用法
	<bean id="" class="">
		<property name="属性名称" value="属性值" />
		...
		<property name="属性名称" value="属性值" />
	</bean>
	property用于对属性的值进行配置，可以有多个
	name：属性的名称
	value：属性的值
	优缺点
	setter注入相对于构造函数注入要灵活一些，构造函数需要指定对应构造函数中所有参数的值，
	而setter注入的方式没有这种限制，不需要对所有属性都进行注入，可以按需进行注入。
	上面介绍的都是注入普通类型的对象，都是通过value属性来设置需要注入的对象的值的，
	value属性的值是String类型的，spring容器内部自动会将value的值转换为对象的实际类型。
	若我们依赖的对象是容器中的其他bean对象的时候，需要用下面的方式进行注入
	注入容器中的bean
	注入容器中的bean有两种写法：
	•	ref属性方式
	•	内置bean的方式
	ref属性方式
	将上面介绍的constructor-arg或者property元素的value属性名称替换为ref，ref属性的值为容器中其他bean的名称，如：
	构造器方式，将value替换为ref：
	<constructor-arg ref="需要注入的bean的名称"/>
	setter方式，将value替换为ref：
	<property name="属性名称" ref="需要注入的bean的名称" />
	内置bean的方式
	构造器的方式：
	<constructor-arg>
		<bean class=""/>
	</constructor-arg>
	setter方式：
	<property name="属性名称">
		<bean class=""/>
	</property>
	其他类型注入
	注入java.util.List（list元素）
	<list>
		<value>Spring</value>
		或
		<ref bean="bean名称"/>
		或
		<list></list>
		或
		<bean></bean>
		或
		<array></array>
		或
		<map></map>
	</list>
	注入java.util.Set（set元素）
	<set>
		<value>Spring</value>
		或
		<ref bean="bean名称"/>
		或
		<list></list>
		或
		<bean></bean>
		或
		<array></array>
		或
		<map></map>
	</set>
	注入java.util.Map（map元素）
	<map>
		<entry key="马士兵老师" value="30" key-ref="key引用的bean名称" value-ref="value引用的bean名称"/>
		或
		<entry>
			<key>
				value对应的值，可以为任意类型
			</key>
			<value>
				value对应的值，可以为任意类型
			</value>
		</entry>
	</map>
	注入数组（array元素）
	<array>
		数组中的元素
	</array>
	注入java.util.Properties（props元素）
	Properties类相当于键值都是String类型的Map对象，使用props进行注入，如下：
	<props>
		<prop key="key1">java高并发系列</prop>
		<prop key="key2">mybatis系列</prop>
		<prop key="key3">mysql系列</prop>
	</props>
	总结
	1.	本文主要讲解了xml中bean的依赖注入，都是采用硬编码的方式进行注入的，这种算是手动的方式
	2.	注入普通类型通过value属性或者value元素设置注入的值；注入对象如果是容器的其他bean的时候，需要使用ref属性或者ref元素或者内置bean元素的方式
	3.	还介绍了其他几种类型List、Set、Map、数组、Properties类型的注入，多看几遍加深理解
	4.	后面我们将介绍spring为我们提供的更牛逼的自动注入
Spring系列第8篇：依赖注入之自动注入（autowire）详解
	手动注入的不足
	上篇文章中介绍了依赖注入中的手动注入，所谓手动注入是指在xml中采用硬编码的方式来配置注入的对象，
	比如通过构造器注入或者set方法注入，这些注入的方式都存在不足
	自动注入
	自动注入是采用约定大约配置的方式来实现的，程序和spring容器之间约定好，遵守某一种都认同的规则，来实现自动注入。
	xml中可以在bean元素中通过autowire属性来设置自动注入的方式：
	<bean id="" class="" autowire="byType|byName|constructor|default" />
	•	byteName：按照名称进行注入
	•	byType：按类型进行注入
	•	constructor：按照构造方法进行注入
	•	default：默认注入方式
	按照名称进行注入（byName）
	用法
	autowire设置为byName
	<bean id="" class="X类" autowire="byName"/>
	spring容器会按照set属性的名称去容器中查找同名的bean对象，然后将查找到的对象通过set方法注入到对应的bean中，未找到对应名称的bean对象则set方法不进行注入
	需要注入的set属性的名称和被注入的bean的名称必须一致。
	优缺点
	按名称进行注入的时候，要求名称和set属性的名称必须同名，相对于硬编码的方式注入，确实节省了不少代码。
	按照类型进行自动注入
	用法
	autowire设置为byType
	<bean id="" class="X类" autowire="byType"/>
	spring容器会遍历x类中所有的set方法，会在容器中查找和set参数类型相同的bean对象，
	将其通过set方法进行注入，未找到对应类型的bean对象则set方法不进行注入。
	需要注入的set属性的类型和被注入的bean的类型需要满足isAssignableFrom关系。
	按照类型自动装配的时候，如果按照类型找到了多个符合条件的bean，系统会报错。
	set方法的参数如果是下面的类型或者下面类型的数组的时候，这个set方法会被跳过注入：
	Object,Boolean,boolean,Byte,byte,Character,char,Double,double,Float,float,Integer,int,Long,
	Short,shot,Enum,CharSequence,Number,Date,java.time.temporal.Temporal,java.net.URI,java.net.URI,
	java.util.Locale,java.lang.Class
	优缺点
	相对于手动注入，节省了不少代码，新增或者删除属性，只需要增减对应的set方法就可以了，更容易扩展了。
	注入类型匹配的所有bean(重点)
	按照类型注入还有2中比较牛逼的用法
	•	一个容器中满足某种类型的bean可以有很多个，将容器中某种类型中的所有bean，
	通过set方法注入给一个java.util.List<需要注入的Bean的类型或者其父类型或者其接口>对象
	•	将容器中某种类型中的所有bean，通过set方法注入给一个java.util.Map<String,需要注入的Bean的类型或者其父类型或者其接口>对象
	按照构造函数进行自动注入
	用法
	autowire设置为constructor
	<bean id="" class="X类" autowire="constructor"/>
	spring会找到x类中所有的构造方法（一个类可能有多个构造方法），然后将这些构造方法进行排序
	（先按修饰符进行排序，public的在前面，其他的在后面，如果修饰符一样的，会按照构造函数参数数量倒叙，
	也就是采用贪婪的模式进行匹配，spring容器会尽量多注入一些需要的对象）得到一个构造函数列表，会轮询这个构造器列表，
	判断当前构造器所有参数是否在容器中都可以找到匹配的bean对象，如果可以找到就使用这个构造器进行注入，
	如果不能找到，那么就会跳过这个构造器，继续采用同样的方式匹配下一个构造器，直到找到一个合适的为止。	
	autowire=default
	用法
	bean xml的根元素为beans，注意根元素有个default-autowire属性，
	这个属性可选值有(no|byName|byType|constructor|default)，
	这个属性可以批量设置当前文件中所有bean的自动注入的方式，
	bean元素中如果省略了autowire属性，那么会取default-autowire的值作为其autowire的值，
	而每个bean元素还可以单独设置自己的autowire覆盖default-autowire的配置
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		   xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-4.3.xsd"
		   default-autowire="byName">

	</beans>
	总结
	•	xml中手动注入存在的不足之处，可以通过自动注入的方式来解决，本文介绍了3中自动注入：
	通过名称自动注入、通过类型自动注入、通过构造器自动注入
	•	按类型注入中有个比较重要的是注入匹配类型所有的bean，可以将某种类型所有的bean注入给一个List对象，
	可以将某种类型的所有bean按照bean名称->bean对象的映射方式注入给一个Map对象，这种用法比较重要，用途比较大，要掌握
	•	spring中还有其他自动注入的方式，用起来会更爽，后面的文章中我们会详细介绍。
Spring系列第9篇：depend-on干什么的
	1.	bean对象的创建顺序和bean xml中定义的顺序一致
	2.	bean销毁的顺序和bean xml中定义的顺序相反
	1.	bean对象的创建顺序和bean依赖的顺序一致
	2.	bean销毁的顺序和bean创建的顺序相反
	通过depend-on干预bean创建和销毁顺序
	上面看到了对于无依赖的bean，通过定义的顺序确实可以干预bean的创建顺序，通过强依赖也可以干预bean的创建顺序。
	那么如果xml中定义的bean特别多，而有些bean之间也没有强依赖关系，此时如果想去调整bean的创建和销毁的顺序，
	得去调整xml中bean的定义顺序，或者去加强依赖，这样是非常不好的，spring中可以通过depend-on来解决这些问题，
	在不调整bean的定义顺序和强加依赖的情况下，可以通过通过depend-on属性来设置当前bean的依赖于哪些bean，
	那么可以保证depend-on指定的bean在当前bean之前先创建好，销毁的时候在当前bean之后进行销毁。
	depend-on使用方式：
	<bean id="bean1" class="" depend-on="bean2,bean3; bean4" />
	depend-on：设置当前bean依赖的bean名称，可以指定多个，多个之间可以用”,;空格“进行分割
	上面不管bean2,bean2,bean4在任何地方定义，都可以确保在bean1创建之前，会先将bean2,bean3,bean4创建好，
	表示bean1依赖于这3个bean，可能bean1需要用到bean2、bean3、bean4中生成的一些资源或者其他的功能等，
	但是又没有强制去在bean1类中通过属性定义强依赖的方式去依赖于bean2、bean3、bean4；
	当然销毁的时候也会先销毁当前bean，再去销毁被依赖的bean，即先销毁bean1，再去销毁depend-on指定的bean
	1.	无依赖的bean创建顺序和定义的顺序一致，销毁顺序刚好相反
	2.	通过构造器强依赖的bean，会先创建构造器参数中对应的bean，然后才会创建当前bean，销毁顺序刚好相反
	3.	depend-on可以指定档期bean依赖的bean，通过这个可以确保depend-on指定的bean在当前bean创建之前先创建好，销毁顺序刚好相反
Spring系列第10篇：primary可以解决什么问题
	org.springframework.beans.factory.NoUniqueBeanDefinitionException
	当希望从容器中获取到一个bean对象的时候，容器中却找到了多个匹配的bean，此时spring不知道如何选择了，处于懵逼状态，就会报这个异常。
	spring中可以通过bean元素的primary属性来解决这个问题，可以通过这个属性来指定当前bean为主要候选者，
	当容器查询一个bean的时候，如果容器中有多个候选者匹配的时候，此时spring会返回主要的候选者。
	我们将serviceA的primary属性置为true了，将其置为主要候选者，容器中如果查找bean的时候，如果有多个匹配的，就以他为主。
	候选者中如果有多个bean都将primary置为true，此时spring还是会懵逼的，也会报错，不知道如何选择了。
	总结
	当从容器中查找一个bean的时候，如果容器中出现多个Bean候选者时，
	可以通过primary="true"将当前bean置为首选者，那么查找的时候就会返回主要的候选者，否则将抛出异常。
Spring系列第11篇：bean中的autowire-candidate属性又是干什么的
	spring还有一种方法也可以解决这个问题，可以设置某个bean是否在自动注入的时候是否为作为候选bean，通过bean元素的autowire-candidate属性类配置，如下：
	<bean id="serviceA" class="com.javacode2018.lesson001.demo8.SetterBean$ServiceA" autowire-candidate="false"/>
	autowire-candidate：设置当前bean在被其他对象作为自动注入对象的时候，是否作为候选bean，默认值是true。
	autowire-candidates属性解析源码
	beans元素是xml中定义bean的根元素，beans元素有个default-autowire-candidates属性，
	用于定义哪些bean可以作为候选者，default-autowire-candidates的值是个通配符如：
	default-autowire-candidates="*Service"
	再来说一下bean元素的autowire-candidate属性，这个属性有3个可选值：
	•	default：这个是默认值，autowire-candidate如果不设置，其值就是default
	•	true：作为候选者
	•	false：不作为候选者
Spring系列第12篇：lazy-init：bean延迟初始化
	bean初始化的2种方式
	1.	实时初始化
	2.	延迟初始化
	bean实时初始化
	在容器启动过程中被创建组装好的bean，称为实时初始化的bean，
	spring中默认定义的bean都是实时初始化的bean，这些bean默认都是单例的，在容器启动过程中会被创建好，然后放在spring容器中以供使用。
	实时初始化bean的有一些优点
	1.	更早发下bean定义的错误：实时初始化的bean如果定义有问题，会在容器启动过程中会抛出异常，让开发者快速发现问题
	2.	查找bean更快：容器启动完毕之后，实时初始化的bean已经完全创建好了，
	此时被缓存在spring容器中，当我们需要使用的时候，容器直接返回就可以了，速度是非常快的
	延迟初始化的bean
	从上面我们可以看出，实时初始化的bean都会在容器启动过程中创建好，如果程序中定义的bean非常多，
	并且有些bean创建的过程中比较耗时的时候，会导致系统消耗的资源比较多，并且会让整个启动时间比较长，
	这个我估计大家都是有感受的，使用spring开发的系统比较大的时候，整个系统启动耗时是比较长的，基本上多数时间都是在创建和组装bean。
	spring对这些问题也提供了解决方案：bean延迟初始化。
	所谓延迟初始化，就是和实时初始化刚好相反，延迟初始化的bean在容器启动过程中不会创建，而是需要使用的时候才会去创建，
	先说一下bean什么时候会被使用：
	1.	被其他bean作为依赖进行注入的时候，比如通过property元素的ref属性进行引用，通过构造器注入、
	通过set注入、通过自动注入，这些都会导致被依赖bean的创建
	2.	开发者自己写代码向容器中查找bean的时候，如调用容器的getBean方法获取bean。
	延迟bean的配置
	在bean定义的时候通过lazy-init属性来配置bean是否是延迟加载，true：延迟初始化，false：实时初始化
	<bean lazy-init="是否是延迟初始化" />
	总结
	延迟初始化的bean无法在程序启动过程中迅速发现bean定义的问题，
	第一次获取的时候可能耗时会比较长。在实际工作中用的比较少，作为了解，以后碰到的时候会有个印象。
Spring系列第13篇：使用继承简化bean配置(abstract & parent)
	上面多了一个baseService的bean，这个bean没有指定class对象，但是多了一个abstract="true"的属性，
	表示这个bean是抽象的，abstract为true的bean在spring容器中不会被创建，只是会将其当做bean定义的模板，
	而serviceB和serviceC的定义中多了一个属性parent，用来指定当前bean的父bean名称，此处是baseService，
	此时serviceB和serviceC会继承baseService中定义的配置信息。
	子bean中也可以重新定义父bean中已经定义好的配置，这样子配置会覆盖父bean中的配置信息
	总结
	1.	bean元素的abstract属性为true的时候可以定义某个bean为一个抽象的bean，相当于定义了一个bean模板，
	spring容器并不会创建这个bean，从容器中查找abstract为true的bean的时候，会报错BeanIsAbstractException异常
	2.	bean元素的parent属性可以指定当前bean的父bean，子bean可以继承父bean中配置信息，
	也可以自定义配置信息，这样可以覆盖父bean中的配置
Spring系列第14篇：lookup-method和replaced-method
	lookup-method：方法查找
	通常情况下，我们使用的bean都是单例的，如果一个bean需要依赖于另一个bean的时候，
	可以在当前bean中声明另外一个bean引用，然后注入依赖的bean，此时被依赖的bean在当前bean中自始至终都是同一个实例。
	单例bean中使用多例bean：lookup-method方式实现
	上面这种方式实现了单例bean中使用多例bean的需求，但是用到spring中的接口ApplicationContextAware，
	此时对spring的api有耦合的作用，我们一直推行高内聚低耦合，所以我们得寻求更好的办法。
	能不能有这样的功能，当serviceB中调用getServiceA的时候，系统自动将这个方法拦截，
	然后去spring容器中查找对应的serviceA对象然后返回，spring中的lookup-method就可以实现这样的功能。
	lookup-method：看其名字，就知道意思：方法查找，调用name属性指定的方法的时候，spring会对这个方法进行拦截，
	然后去容器中查找lookup-method元素中bean属性指定的bean，然后将找到的bean作为方法的返回值返回。这个地方底层是使用cglib代理实现的
	replaced-method：方法替换
	replaced-method：方法替换，比如我们要调用serviceB中的getServiceA的时候，
	我们可以对serviceB这个bean中的getServiceA方法进行拦截，把这个调用请求转发到一个替换者处理。
	这就是replaced-method可以实现的功能，比lookup-method更强大更灵活。
	总结
	1.	lookup-method：方法查找，可以对指定的bean的方法进行拦截，然后从容器中查找指定的bean作为被拦截方法的返回值
	2.	replaced-method：方法替换，可以实现bean方法替换的效果，整体来说比lookup-method更灵活一些
	3.	单例bean中使用多例bean，本文中列出了3种方式，
Spring系列第15篇：代理详解（java动态代理&CGLIB代理)
	代理spring中用到的挺多的，比如上篇文章中的lookup-method和replaced-method，以及后面我们要学的aop、spring中的事务、
	spring中解析@configuration注解等等，这些都是依靠代理来实现的
	通用代理的2种实现：
	1.	jdk动态代理
	2.	cglib代理

	jdk动态代理详解
	jdk中为实现代理提供了支持，主要用到2个类：
	java.lang.reflect.Proxy
	java.lang.reflect.InvocationHandler
	jdk自带的代理使用上面有个限制，只能为接口创建代理类，如果需要给具体的类创建代理类，需要用后面要说的cglib
	getProxyClass方法
	为指定的接口创建代理类，返回代理类的Class对象
	public static Class<?> getProxyClass(ClassLoader loader,
											 Class<?>... interfaces)
	参数说明：
	loader：定义代理类的类加载器
	interfaces：指定需要实现的接口列表，创建的代理默认会按顺序实现interfaces指定的接口
	newProxyInstance方法
	创建代理类的实例对象
	public static Object newProxyInstance(ClassLoader loader,
											  Class<?>[] interfaces,
											  InvocationHandler h)
	这个方法先为指定的接口创建代理类，然后会生成代理类的一个实例，最后一个参数比较特殊，是InvocationHandler类型的，这个是个接口如下：
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable;
	上面方法会返回一个代理对象，当调用代理对象的任何方法的时候，会就被InvocationHandler接口的invoke方法处理，
	所以主要代码需要卸载invoke方法中，稍后会有案例细说。
	isProxy方法
	判断指定的类是否是一个代理类
	public static boolean isProxyClass(Class<?> cl)
	getInvocationHandler方法
	获取代理对象的InvocationHandler对象
	public static InvocationHandler getInvocationHandler(Object proxy)
			throws IllegalArgumentException
	Proxy使用注意
	1.	jdk中的Proxy只能为接口生成代理类，如果你想给某个类创建代理类，那么Proxy是无能为力的，此时需要我们用到下面要说的cglib了。
	2.	Proxy类中提供的几个常用的静态方法大家需要掌握
	3.	通过Proxy创建代理对象，当调用代理对象任意方法时候，会被InvocationHandler接口中的invoke方法进行处理，这个接口内容是关键
	cglib代理详解
	什么是cglib
	jdk动态代理只能为接口创建代理，使用上有局限性。实际的场景中我们的类不一定有接口，
	此时如果我们想为普通的类也实现代理功能，我们就需要用到cglib来实现了。
	cglib是一个强大、高性能的字节码生成库，它用于在运行时扩展Java类和实现接口；
	本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法）。
	Enhancer可能是CGLIB中最常用的一个类，和jdk中的Proxy不同的是，Enhancer既能够代理普通的class，也能够代理接口。
	Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。
	Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于Java final方法语义决定的。
	基于同样的道理，Enhancer也不能对final类进行代理操作。
	CGLIB作为一个开源项目，其代码托管在github，地址为：
	https://github.com/cglib/cglib
	CGLIB底层使用了ASM（一个短小精悍的字节码操作框架）来操作字节码生成新的类。
	除了CGLIB库外，脚本语言（如Groovy和BeanShell）也使用ASM生成字节码。
	ASM使用类似SAX的解析器来实现高性能。我们不鼓励直接使用ASM，因为它需要对Java字节码的格式足够的了解。
	spring已将第三方cglib jar包中所有的类集成到spring自己的jar包中，
	本系列内容都是和spring相关的，为了方便，我们直接使用spring内部已集成的来讲解
	上面代码中的注释很详细，列出了给指定的类创建代理的具体步骤，整个过程中主要用到了Enhancer类和MethodInterceptor接口。
	enhancer.setSuperclass用来设置代理类的父类，即需要给哪个类创建代理类，此处是Service1
	enhancer.setCallback传递的是MethodInterceptor接口类型的参数，MethodInterceptor接口有个intercept方法，
	这个方法会拦截代理对象所有的方法调用。
	还有一个重点是Object result = methodProxy.invokeSuper(o, objects);可以调用被代理类，
	也就是Service1类中的具体的方法，从方法名称的意思可以看出是调用父类，实际对某个类创建代理，
	cglib底层通过修改字节码的方式为Service1类创建了一个子类。
	CGLIB和Java动态代理的区别
	1.	Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，
	Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
	2.	Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；
	CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效
Spring系列第16篇：深入理解java注解
	代码中注释大家都熟悉吧，注释是给开发者看的，可以提升代码的可读性和可维护性，
	但是对于java编译器和虚拟机来说是没有意义的，编译之后的字节码文件中是没有注释信息的；
	而注解和注释有点类似，唯一的区别就是注释是给人看的，而注释是给编译器和虚拟机看的，
	编译器和虚拟机在运行的过程中可以获取注解信息，然后可以根据这些注解的信息做各种想做的事情。
	比如：大家对@Override应该比较熟悉，就是一个注解，加在方法上，标注当前方法重写了父类的方法，当编译器编译代码的时候，
	会对@Override标注的方法进行验证，验证其父类中是否也有同样签名的方法，否则报错，通过这个注解是不是增强了代码的安全性。
	总的来说：注解是对代码的一种增强，可以在代码编译或者程序运行期间获取注解的信息，然后根据这些信息做各种牛逼的事情
	定义注解语法
	jdk中注解相关的类和接口都定义在java.lang.annotation包中。
	注解的定义和我们常见的类、接口类似，只是注解使用@interface来定义
	注解中定义参数
	注解有没有参数都可以，定义参数如下：
	public @interface 注解名称{
		[public] 参数类型 参数名称1() [default 参数默认值];
		[public] 参数类型 参数名称2() [default 参数默认值];
		[public] 参数类型 参数名称n() [default 参数默认值];
	}
	注解中可以定义多个参数，参数的定义有以下特点：
	1.	访问修饰符必须为public，不写默认为public
	2.	该元素的类型只能是基本数据类型、String、Class、枚举类型、注解类型（体现了注解的嵌套效果）以及上述类型的一位数组
	3.	该元素的名称一般定义为名词，如果注解中只有一个元素，请把名字起为value（后面使用会带来便利操作）
	4.	参数名称后面的()不是定义方法参数的地方，也不能在括号中定义任何参数，仅仅只是一个特殊的语法
	5.	default代表默认值，值必须和第2点定义的类型一致
	6.	如果没有默认值，代表后续使用注解时必须给该类型元素赋值
	指定注解的使用范围：@Target
	使用@Target注解定义注解的使用范围，如下：
	@Target(value = {ElementType.TYPE,ElementType.METHOD})
	public @interface MyAnnotation {
	}
	上面指定了MyAnnotation注解可以用在类、接口、注解类型、枚举类型以及方法上面，
	自定义注解上也可以不使用@Target注解，如果不使用，表示自定义注解可以用在任何地方。
	看一下@Target源码：
	@Documented
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.ANNOTATION_TYPE)
	public @interface Target {
		ElementType[] value();
	}
	有一个参数value，是ElementType类型的一个数组，再来看一下ElementType，是个枚举，源码如下：
	package java.lang.annotation;
	/*注解的使用范围*/
	public enum ElementType {
		/*类、接口、枚举、注解上面*/
		TYPE,
		/*字段上*/
		FIELD,
		/*方法上*/
		METHOD,
		/*方法的参数上*/
		PARAMETER,
		/*构造函数上*/
		CONSTRUCTOR,
		/*本地变量上*/
		LOCAL_VARIABLE,
		/*注解上*/
		ANNOTATION_TYPE,
		/*包上*/
		PACKAGE,
		/*类型参数上*/
		TYPE_PARAMETER,
		/*类型名称上*/
		TYPE_USE
	}
	指定注解的保留策略：@Retention
	我们先来看一下java程序的3个过程
	1.	源码阶段
	2.	源码被编译为字节码之后变成class文件
	3.	字节码被虚拟机加载然后运行
	那么自定义注解会保留在上面哪个阶段呢？可以通过@Retention注解来指定，如：
	@Retention(RetentionPolicy.SOURCE)
	public @interface MyAnnotation {
	}
	上面指定了MyAnnotation只存在于源码阶段，后面的2个阶段都会丢失。
	来看一下@Retention
	@Documented
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.ANNOTATION_TYPE)
	public @interface Retention {
		RetentionPolicy value();
	}
	有一个value参数，类型为RetentionPolicy枚举，如下：
	public enum RetentionPolicy {
		/*注解只保留在源码中，编译为字节码之后就丢失了，也就是class文件中就不存在了*/
		SOURCE,
		/*注解只保留在源码和字节码中，运行阶段会丢失*/
		CLASS,
		/*源码、字节码、运行期间都存在*/
		RUNTIME
	}
	使用注解
	语法
	将注解加载使用的目标上面，如下：
	@注解名称(参数1=值1,参数2=值2,参数n=值n)
	目标对象
	为了运行时能准确获取到注解的相关信息，Java在java.lang.reflect 反射包下新增了AnnotatedElement接口，
	它主要用于表示目前正在虚拟机中运行的程序中已使用注解的元素，通过该接口提供的方法可以利用反射技术地读取注解的信息
	•	Package：用来表示包的信息
	•	Class：用来表示类的信息
	•	Constructor：用来表示构造方法信息
	•	Field：用来表示类中属性信息
	•	Method：用来表示方法信息
	•	Parameter：用来表示方法参数信息
	•	TypeVariable：用来表示类型变量信息，如：类上定义的泛型类型变量，方法上面定义的泛型类型变量
	AnnotatedElement常用方法
	fdsfd
	返回值	方法名称	说明
	<A extends Annotation>	getAnnotation(Class<A> annotationClass)	该元素如果存在指定类型的注解，则返回这些注解，否则返回 null。
	Annotation[]	getAnnotations()	返回此元素上存在的所有注解，包括从父类继承的
	boolean	isAnnotationPresent(Class<? extends Annotation> annotationClass)	如果指定类型的注解存在于此元素上，则返回 true，否则返回 false。
	Annotation[]	getDeclaredAnnotations()	返回直接存在于此元素上的所有注解，注意，不包括父类的注解，
	调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响，没有则返回长度为0的数组
	@Inherit：实现类之间的注解继承
	我们通过@Target元注解的属性值可以看出，这个@Inherited 是专门修饰注解的。
	作用：让子类可以继承父类中被@Inherited修饰的注解，注意是继承父类中的，
	如果接口中的注解也使用@Inherited修饰了，那么接口的实现类是无法继承这个注解的
	想重复使用注解的时候，需要用到@Repeatable注解
	Spring @AliasFor：对注解进行增强
	@AliasFor(annotation = A14.class, value = "value")
	这个相当于给某个注解指定别名，即将B1注解中a14Value参数作为A14中value参数的别名，
	当给B1的a14Value设置值的时候，就相当于给A14的value设置值，有个前提是@AliasFor注解的annotation参数指定的注解需要加载当前注解上面，
	AliasFor注解中value和attribute互为别名，随便设置一个，同时会给另外一个设置相同的值。
	@AliasFor中不指定value和attribute
	当@AliasFor中不指定value或者attribute的时候，自动将@AliasFor修饰的参数作为value和attribute的值，
Spring系列第17篇：@Configration和@Bean注解
	@Configuration注解
	@Configuration这个注解可以加在类上，让这个类的功能等同于一个bean xml配置文件
	@Configuration使用步骤：
	1.	在类上使用@Configuration注解
	2.	通过AnnotationConfigApplicationContext容器来加@Configuration注解修饰的类
	@Bean注解
	用法
	这个注解类似于bean xml配置文件中的bean元素，用来在spring容器中注册一个bean。
	@Bean注解用在方法上，表示通过方法来定义一个bean，默认将方法名称作为bean名称，将方法返回值作为bean对象，注册到spring容器中。
	1.	对比最后3行，可以看出：有没有@Configuration注解，@Bean都会起效，都会将@Bean修饰的方法作为bean注册到容器中
	2.	两个内容的第一行有点不一样，被@Configuration修饰的bean最后输出的时候带有EnhancerBySpringCGLIB的字样，
	而没有@Configuration注解的bean没有Cglib的字样；有EnhancerBySpringCGLIB字样的说明这个bean被cglib处理过的，变成了一个代理对象。
	被@Configuration修饰的类，spring容器中会通过cglib给这个类创建一个代理，代理会拦截所有被@Bean修饰的方法，
	默认情况（bean为单例）下确保这些方法只被调用一次，从而确保这些bean是同一个bean，即单例的。
	1.	@Configuration注解修饰的类，会被spring通过cglib做增强处理，通过cglib会生成一个代理对象，
	代理会拦截所有被@Bean注解修饰的方法，可以确保一些bean是单例的
	2.	不管@Bean所在的类上是否有@Configuration注解，都可以将@Bean修饰的方法作为一个bean注册到spring容器中
Spring系列第18篇：@ComponentScan、@ComponentScans详解
	@ComponentScan
	@ComponentScan用于批量注册bean。
	这个注解会让spring去扫描某些包及其子包中所有的类，然后将满足一定条件的类作为bean注册到spring容器容器中。
	定义上可以看出此注解可以用在任何类型上面，不过我们通常将其用在类上面。
	常用参数：
	value：指定需要扫描的包，如：com.javacode2018
	basePackages：作用同value；value和basePackages不能同时存在设置，可二选一
	basePackageClasses：指定一些类，spring容器会扫描这些类所在的包及其子包中的类
	nameGenerator：自定义bean名称生成器
	resourcePattern：需要扫描包中的那些资源，默认是：*/\.class，即会扫描指定包中所有的class文件
	useDefaultFilters：对扫描的类是否启用默认过滤器，默认为true
	includeFilters：过滤器：用来配置被扫描出来的那些类会被作为组件注册到容器中
	excludeFilters：过滤器，和includeFilters作用刚好相反，用来对扫描的类进行排除的，被排除的类不会被注册到容器中
	lazyInit：是否延迟初始化被注册的bean
	@ComponentScan工作的过程：
	1.	Spring会扫描指定的包，且会递归下面子包，得到一批类的数组
	2.	然后这些类会经过上面的各种过滤器，最后剩下的类会被注册到容器中
	所以玩这个注解，主要关注2个问题：
	第一个：需要扫描哪些包？通过value、backPackages、basePackageClasses这3个参数来控制
	第二：过滤器有哪些？通过useDefaultFilters、includeFilters、excludeFilters这3个参数来控制过滤器
	这两个问题搞清楚了，就可以确定哪些类会被注册到容器中。
	默认情况下，任何参数都不设置的情况下，此时，会将@ComponentScan修饰的类所在的包作为扫描包；
	默认情况下useDefaultFilters为true，这个为true的时候，spring容器内部会使用默认过滤器，规则是：
	凡是类上有@Repository、@Service、@Controller、@Component这几个注解中的任何一个的，
	那么这个类就会被作为bean注册到spring容器中，所以默认情况下，只需在类上加上这几个注解中的任何一个，
	这些类就会自动交给spring容器来管理了。
	value参数：被注册为bean的时候，用来指定bean的名称，如果不指定，默认为类名首字母小写。
	@controller通常用来标注controller层组件，
	@service注解标注service层的组件，
	@Repository标注dao层的组件，这样可以让整个系统的结构更清晰，当看到这些注解的时候，会和清晰的知道属于哪个层，
	对于spring来说，将这3个注解替换成@Component注解，对系统没有任何影响，产生的效果是一样的。
	@ComponentScan({
        "com.javacode2018.lesson001.demo22.test1.controller",
        "com.javacode2018.lesson001.demo22.test1.service"
	})
	指定包名的方式扫描存在的一个隐患，若包被重名了，会导致扫描会失效，
	一般情况下面我们使用basePackageClasses的方式来指定需要扫描的包，这个参数可以指定一些类型，
	默认会扫描这些类所在的包及其子包中所有的类，这种方式可以有效避免这种问题。
	@ComponentScan(basePackageClasses = ScanClass.class)
	includeFilters的使用
	用法
	再来看一下includeFilters这个参数的定义：
	Filter[] includeFilters() default {};
	是一个Filter类型的数组，多个Filter之间为或者关系，即满足任意一个就可以了
	Filter也是一个注解，参数：
	type：过滤器的类型，是个枚举类型，5种类型
	ANNOTATION：通过注解的方式来筛选候选者，即判断候选者是否有指定的注解
	ASSIGNABLE_TYPE：通过指定的类型来筛选候选者，即判断候选者是否是指定的类型
	ASPECTJ：ASPECTJ表达式方式，即判断候选者是否匹配ASPECTJ表达式
	REGEX：正则表达式方式，即判断候选者的完整名称是否和正则表达式匹配
	CUSTOM：用户自定义过滤器来筛选候选者，对候选者的筛选交给用户自己来判断

	value：和参数classes效果一样，二选一
	classes：3种情况如下
	当type=FilterType.ANNOTATION时，通过classes参数可以指定一些注解，用来判断被扫描的类上是否有classes参数指定的注解
	当type=FilterType.ASSIGNABLE_TYPE时，通过classes参数可以指定一些类型，用来判断被扫描的类是否是classes参数指定的类型
	当type=FilterType.CUSTOM时，表示这个过滤器是用户自定义的，classes参数就是用来指定用户自定义的过滤器，
	自定义的过滤器需要实现org.springframework.core.type.filter.TypeFilter接口

	pattern：2种情况如下
	当type=FilterType.ASPECTJ时，通过pattern来指定需要匹配的ASPECTJ表达式的值
	当type=FilterType.REGEX时，通过pattern来自正则表达式的值
	MetadataReader接口
	类元数据读取器，可以读取一个类上的任意信息，如类上面的注解信息、类的磁盘路径信息、类的class对象的各种信息，
	spring进行了封装，提供了各种方便使用的方法。
	MetadataReaderFactory接口
	类元数据读取器工厂，可以通过这个类获取任意一个类的MetadataReader对象
	useDefaultFilters = false, //不启用默认过滤器
	@CompontentScan注解是被下面这个类处理的
	org.springframework.context.annotation.ConfigurationClassPostProcessor
	这个类非常非常关键，主要用户bean的注册，前面我们介绍的@Configuration,@Bean注解也是被这个类处理的。
	还有下面这些注解：
	@PropertySource
	@Import
	@ImportResource
	@Compontent
	以上这些注解都是被ConfigurationClassPostProcessor这个类处理的，内部会递归处理这些注解，完成bean的注册。
	以@CompontentScan来说一下过程，第一次扫描之后会得到一批需要注册的类，然后会对这些需要注册的类进行遍历，
	判断是否有上面任意一个注解，如果有，会将这个类交给ConfigurationClassPostProcessor继续处理，直到递归完成所有bean的注册。
	
	1.	@ComponentScan用于批量注册bean，spring会按照这个注解的配置，递归扫描指定包中的所有类，将满足条件的类批量注册到spring容器中
	2.	可以通过value、basePackages、basePackageClasses 这几个参数来配置包的扫描范围
	3.	可以通过useDefaultFilters、includeFilters、excludeFilters这几个参数来配置类的过滤器，被过滤器处理之后剩下的类会被注册到容器中
	4.	指定包名的方式配置扫描范围存在隐患，包名被重命名之后，会导致扫描实现，所以一般我们在需要扫描的包中可以创建一个标记的接口或者类，作为basePackageClasses的值，通过这个来控制包的扫描范围
	5.	@CompontScan注解会被ConfigurationClassPostProcessor类递归处理，最终得到所有需要注册的类。
Spring系列第19篇：@Import批量注册bean
	@Import使用
	先看Spring对它的注释，总结下来作用就是和xml配置的 <import />标签作用一样，
	允许通过它引入@Configuration标注的类 ， 引入ImportSelector接口和ImportBeanDefinitionRegistrar接口的实现，
	也包括 @Component注解的普通类。
	总的来说：@Import可以用来批量导入需要注册的各种类，如普通的类、配置类，完后完成普通类和配置类中所有bean的注册。
	@Import可以使用在任何类型上，通常情况下，类和注解上用的比较多。
	value：一个Class数组，设置需要导入的类，可以是@Configuration标注的列，
	可以是ImportSelector接口或者ImportBeanDefinitionRegistrar接口类型的，或者需要导入的普通组件类
	使用步骤
	1.	将@Import标注在类上，设置value参数
	2.	将@Import标注的类作为AnnotationConfigApplicationContext构造参数创建AnnotationConfigApplicationContext对象
	3.	使用AnnotationConfigApplicationContext对象
	@Import的value常见的有5种用法
	1.	value为普通的类
	2.	value为@Configuration标注的类
	3.	value为@CompontentScan标注的类
	4.	value为ImportBeanDefinitionRegistrar接口类型
	5.	value为ImportSelector接口类型
	6.	value为DeferredImportSelector接口类型
	按模块的方式进行导入，需要哪个导入哪个，不需要的时候，直接修改一下总的配置类，调整一下@Import就可以了，非常方便。
	value为@Configuration标注的配置类
	项目比较大的情况下，会按照模块独立开发，每个模块在maven中就表现为一个个的构建，然后通过坐标的方式进行引入需要的模块。
	value为@CompontentScan标注的类
	项目中分多个模块，每个模块有各自独立的包，我们在每个模块所在的包中配置一个@CompontentScan类，然后通过@Import来导入需要启用的模块。
	ImportBeanDefinitionRegistrar接口
	这个接口提供了通过spring容器api的方式直接向容器中注册bean。
	接口的完整名称：
	org.springframework.context.annotation.ImportBeanDefinitionRegistrar
	源码：
	public interface ImportBeanDefinitionRegistrar {

		default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,
				BeanNameGenerator importBeanNameGenerator) {

			registerBeanDefinitions(importingClassMetadata, registry);
		}

		default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		}

	}
	2个默认方法，都可以用来调用spring容器api来注册bean。
	2个方法中主要有3个参数
	importingClassMetadata
	AnnotationMetadata类型的，通过这个可以获取被@Import注解标注的类所有注解的信息。
	registry
	BeanDefinitionRegistry类型，是一个接口，内部提供了注册bean的各种方法。
	importBeanNameGenerator
	BeanNameGenerator类型，是一个接口，内部有一个方法，用来生成bean的名称。
	关于BeanDefinitionRegistry和BeanNameGenerator接口在来细说一下。
	BeanDefinitionRegistry接口：bean定义注册器
	bean定义注册器，提供了bean注册的各种方法，来看一下源码：
	public interface BeanDefinitionRegistry extends AliasRegistry {

		/**
		 * 注册一个新的bean定义
		 * beanName：bean的名称
		 * beanDefinition：bean定义信息
		 */
		void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
				throws BeanDefinitionStoreException;

		/**
		 * 通过bean名称移除已注册的bean
		 * beanName：bean名称
		 */
		void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;

		/**
		 * 通过名称获取bean的定义信息
		 * beanName：bean名称
		 */
		BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;

		/**
		 * 查看beanName是否注册过
		 */
		boolean containsBeanDefinition(String beanName);

		/**
		 * 获取已经定义（注册）的bean名称列表
		 */
		String[] getBeanDefinitionNames();

		/**
		 * 返回注册器中已注册的bean数量
		 */
		int getBeanDefinitionCount();

		/**
		 * 确定给定的bean名称或者别名是否已在此注册表中使用
		 * beanName：可以是bean名称或者bean的别名
		 */
		boolean isBeanNameInUse(String beanName);

	}
	基本上所有bean工厂都实现了这个接口，让bean工厂拥有bean注册的各种能力。
	上面我们用到的AnnotationConfigApplicationContext类也实现了这个接口。
	BeanNameGenerator接口：bean名称生成器
	bean名称生成器，这个接口只有一个方法，用来生成bean的名称：
	public interface BeanNameGenerator {
		String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry);
	}
	spring内置了3个实现
	DefaultBeanNameGenerator
	默认bean名称生成器，xml中bean未指定名称的时候，默认就会使用这个生成器，默认为：完整的类名#bean编号
	AnnotationBeanNameGenerator
	注解方式的bean名称生成器，比如通过@Component(bean名称)的方式指定bean名称，如果没有通过注解方式指定名称，默认会将完整的类名作为bean名称。
	FullyQualifiedAnnotationBeanNameGenerator
	将完整的类名作为bean的名称
	BeanDefinition接口：bean定义信息
	用来表示bean定义信息的接口，我们向容器中注册bean之前，会通过xml或者其他方式定义bean的各种配置信息，
	bean的所有配置信息都会被转换为一个BeanDefinition对象，然后通过容器中BeanDefinitionRegistry接口中的方法，
	将BeanDefinition注册到spring容器中，完成bean的注册操作。
	value为ImportBeanDefinitionRegistrar接口类型
	用法（4个步骤）
	1. 定义ImportBeanDefinitionRegistrar接口实现类，在registerBeanDefinitions方法中使用registry来注册bean
	2. 使用@Import来导入步骤1中定义的类
	3. 使用步骤2中@Import标注的类作为AnnotationConfigApplicationContext构造参数创建spring容器
	4. 使用AnnotationConfigApplicationContext操作bean
	DeferredImportSelector接口
	DeferredImportSelector是ImportSelector的子接口，既然是ImportSelector的子接口，
	所以也可以通过@Import进行导入，这个接口和ImportSelector不同地方有两点：
	1.	延迟导入
	2.	指定导入的类的处理顺序
	延迟导入
	比如@Import的value包含了多个普通类、多个@Configuration标注的配置类、多个ImportSelector接口的实现类，
	多个ImportBeanDefinitionRegistrar接口的实现类，还有DeferredImportSelector接口实现类，
	此时spring处理这些被导入的类的时候，会将DeferredImportSelector类型的放在最后处理，
	会先处理其他被导入的类，其他类会按照value所在的前后顺序进行处理。
	那么我们是可以做很多事情的，比如我们可以在DeferredImportSelector导入的类中判断一下容器中是否已经注册了某个bean，
	如果没有注册过，那么再来注册。
	以后我们会讲到另外一个注解@Conditional，这个注解可以按条件来注册bean，
	比如可以判断某个bean不存在的时候才进行注册，某个类存在的时候才进行注册等等各种条件判断，
	通过@Conditional来结合DeferredImportSelector可以做很多事情。
	总结
	1.	@Import可以用来批量导入任何普通的组件、配置类，将这些类中定义的所有bean注册到容器中
	2.	@Import常见的5种用法需要掌握
	3.	掌握ImportSelector、ImportBeanDefinitionRegistrar、DeferredImportSelector的用法
	4.	DeferredImportSelector接口可以实现延迟导入、按序导入的功能
	5.	spring中很多以@Enable开头的都是使用@Import集合ImportSelector方式实现的
	6.	BeanDefinitionRegistry接口：bean定义注册器，这个需要掌握常见的方法
Spring系列第20篇：@Conditional通过条件来控制bean的注册
	@Conditional注解
	@Conditional注解是从spring4.0才有的，可以用在任何类型或者方法上面，通过@Conditional注解可以配置一些条件判断，
	当所有条件都满足的时候，被@Conditional标注的目标才会被spring容器处理。
Spring系列第21篇：注解实现依赖注入（@Autowired、@Resource、@Primary、@Qulifier）
	@Autowired：注入依赖对象
	作用
	实现依赖注入，spring容器会对bean中所有字段、方法进行遍历，标注有@Autowired注解的，都会进行注入。
	参数：
	required：标注的对象是否必须注入，可能这个对象在容器中不存在，如果为true的时候，
	找不到匹配的候选者就会报错，为false的时候，找不到也没关系 。
	@Autowired查找候选者可以简化为下面这样
	按类型找->通过限定符@Qualifier过滤->@Primary->@Priority->根据名称找（字段名称或者参数名称）
	概括为：先按类型找，然后按名称找
	@Resource：注意依赖对象
	作用
	和@Autowired注解类似，也是用来注入依赖的对象的，spring容器会对bean中所有字段、方法进行遍历，标注有@Resource注解的，都会进行注入。
	这个注解是javax中定义的，并不是spring中定义的注解。
	从定义上可以见，这个注解可以用在任何类型上面、字段、方法上面。
	注意点：
	用在方法上的时候，方法参数只能有一个
	@Qualifier：限定符
	作用
	这个单词的意思是：限定符。
	可以在依赖注入查找候选者的过程中对候选者进行过滤。
	@Primary：设置为主要候选者
	注入依赖的过程中，当有多个候选者的时候，可以指定哪个候选者为主要的候选者。
Spring系列第22篇：@Scope、@DependsOn、@ImportResource、@Lazy
	@Scope：指定bean的作用域
	@Scope用来配置bean的作用域，等效于bean xml中的bean元素中的scope属性。
	@DependsOn：指定当前bean依赖的bean
	@DependsOn等效于bean xml中的bean元素中的depend-on属性。
	spring在创建bean的时候，如果bean之间没有依赖关系，那么spring容器很难保证bean实例创建的顺序，
	如果想确保容器在创建某些bean之前，需要先创建好一些其他的bean，可以通过@DependsOn来实现，
	@DependsOn可以指定当前bean依赖的bean，通过这个可以确保@DependsOn指定的bean在当前bean创建之前先创建好
	@ImportResource：配置类中导入bean定义的配置文件
	有些项目，前期可能采用xml的方式配置bean，后期可能想采用spring注解的方式来重构项目，
	但是有些老的模块可能还是xml的方式，spring为了方便在注解方式中兼容老的xml的方式，
	提供了@ImportResource注解来引入bean定义的配置文件。
	通常将其用在配置类上。
	有3个参数：
	•	value和locations效果一样，只能配置其中一个，是一个string类型的数组，用来指定需要导入的配置文件的路径。
	•	reader：用来指定bean定义的读取器，目前我们知道的配置bean的方式有xml文件的方式，注解的方式，
	其实还有其他的方式，比如properties文件的方式，如果用其他的方式，你得告诉spring具体要用那种解析器去解析这个bean配置文件
	这个解析器就是BeanDefinitionReader，以后我们讲BeanDefinition的时候再细说
	资源文件路径的写法
	通常我们的项是采用maven来组织的，配置文件一般会放在resources目录，这个目录中的文件被编译之后会在target/classes目录中。
	spring中资源文件路径最常用的有2种写法：
	1.	以classpath:开头：检索目标为当前项目的classes目录
	2.	以classpath*:开头：检索目标为当前项目的classes目录，以及项目中所有jar包中的目录，
	如果你确定jar不是检索目标，就不要用这种方式，由于需要扫描所有jar包，所以速度相对于第一种会慢一些
	那我们再来说classpath:和classpath*:后面的部分，后面的部分是确定资源文件的位置地方
	相对路径的方式
	classpath:com/javacode2018/lesson001/demo27/test5/beans.xml
	或者
	classpath*:com/javacode2018/lesson001/demo27/test5/beans.xml
	/：绝对路径的方式
	classpath:/com/javacode2018/lesson001/demo27/test5/beans.xml
	*：文件通配符的方式
	classpath:/com/javacode2018/lesson001/demo27/test5/beans-*.xml
	会匹配test5目录中所有以beans-开头的xml结尾的文件
	*：目录通配符的方式
	classpath:/com/javacode2018/lesson001/demo27/*/beans-*.xml
	会匹配demo27中所有子目录中所有以beans-开头的xml结尾的文件，注意这个地方只包含demo27的子目录，不包含子目录的子目录，不会进行递归
	**：递归任意子目录的方式
	classpath:/com/javacode2018/**/beans-*.xml
	**会递归当前目录以及下面任意级的子目录
	@Lazy：延迟初始化
	用法
	@Lazy等效于bean xml中bean元素的lazy-init属性，可以实现bean的延迟初始化。
	所谓延迟初始化：就是使用到的时候才会去进行初始化。
	常用3种方式
	1.	和@Compontent一起标注在类上，可以是这个类延迟初始化
	2.	和@Configuration一起标注在配置类中，可以让当前配置类中通过@Bean注册的bean延迟初始化
	3.	和@Bean一起使用，可以使当前bean延迟初始化
	------------------------
	1.	@Scope：用来定义bean 的作用域；2种用法：第1种：标注在类上；第2种：和@Bean一起标注在方法上
	2.	@DependsOn：用来指定当前bean依赖的bean，可以确保在创建当前bean之前，先将依赖的bean创建好；
	2种用法：第1种：标注在类上；第2种：和@Bean一起标注在方法上
	3.	@ImportResource：标注在配置类上，用来引入bean定义的配置文件
	4.	@Lazy：让bean延迟初始化；常见3种用法：
	第1种：标注在类上；第2种：标注在配置类上，会对配置类中所有的@Bean标注的方法有效；第3种：和@Bean一起标注在方法上
Spring系列第23篇：Bean生命周期详解
	Spring bean生命周期12个环节
	1.	阶段1：Bean元信息配置阶段
	2.	阶段2：Bean元信息解析阶段
	3.	阶段3：将Bean注册到容器中
	4.	阶段4：BeanDefinition合并阶段
	5.	阶段5：Bean Class加载阶段
	6.	阶段6：Bean实例化阶段（2个小阶段）
	–	Bean实例化前阶段
	–	Bean实例化阶段
	7.	阶段7：合并后的BeanDefinition处理
	8.	阶段8：属性赋值阶段（3个小阶段）
	–	Bean实例化后阶段
	–	Bean属性赋值前阶段
	–	Bean属性赋值阶段
	9.	阶段9：Bean初始化阶段（5个小阶段）
	–	Bean Aware接口回调阶段
	–	Bean初始化前阶段
	–	Bean初始化阶段
	–	Bean初始化后阶段
	10.	阶段10：所有单例bean初始化完成后阶段
	11.	阶段11：Bean的使用阶段
	12.	阶段12：Bean销毁前阶段
	13.	阶段13：Bean销毁阶段
	
	阶段1：Bean元信息配置阶段
	这个阶段主要是bean信息的定义阶段。
	Bean信息定义4种方式
	•	API的方式
	•	Xml文件方式
	•	properties文件的方式
	•	注解的方式
	
	Spring容器启动的过程中，会将Bean解析成Spring内部的BeanDefinition结构。 
	不管是是通过xml配置文件的<Bean>标签，还是通过注解配置的@Bean，还是@Compontent标注的类，还是扫描得到的类，
	它最终都会被解析成一个BeanDefinition对象，最后我们的Bean工厂就会根据这份Bean的定义信息，对bean进行实例化、初始化等等操作。
	你可以把BeanDefinition丢给Bean工厂，然后Bean工厂就会根据这个信息帮你生产一个Bean实例，拿去使用。
	BeanDefinition里面里面包含了bean定义的各种信息，如：bean对应的class、scope、lazy信息、dependOn信息、
	autowireCandidate（是否是候选对象）、primary（是否是主要的候选者）等信息。
	BeanDefinition接口：bean定义信息接口
	bean注册者只识别BeanDefinition对象，不管什么方式最后都会将这些bean定义的信息转换为BeanDefinition对象，然后注册到spring容器中
	
	阶段2：Bean元信息解析阶段
	Bean元信息的解析就是将各种方式定义的bean配置信息解析为BeanDefinition对象。
	XML方式解析：XmlBeanDefinitionReader
	spring中提供了一个类XmlBeanDefinitionReader，将xml中定义的bean解析为BeanDefinition对象。
	properties文件定义bean的解析：PropertiesBeanDefinitionReader
	spring中提供了一个类XmlBeanDefinitionReader，将xml中定义的bean解析为BeanDefinition对象，过程和xml的方式类似。
	注解方式：PropertiesBeanDefinitionReader
	注解的方式定义的bean，需要使用PropertiesBeanDefinitionReader这个类来进行解析
	





























	



























































	






	







	







	




































