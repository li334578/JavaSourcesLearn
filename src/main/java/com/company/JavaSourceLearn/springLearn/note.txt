spring是一个简化java企业级开发的一个框架，内部包含了很多技术。
比如：控制反转&依赖注入、面向切面编程、spring事务管理、
通过spring集成其他框架、springmvc、springboot、springcloud等等
spring容器
    spring容器的概念，容器这个名字起的相当好，容器可以放很多东西，
	我们的程序启动的时候会创建spring容器，会给spring容器一个清单，清单中列出了需要创建的对象以及对象依赖关系，
	spring容器会创建和组装好清单中的对象，然后将这些对象存放在spring容器中，当程序中需要使用的时候，可以到容器中查找获取，然后直接使用。
IOC：控制反转
    使用者之前使用B对象的时候都需要自己去创建和组装，而现在这些创建和组装都交给spring容器去给完成了，
	使用者只需要去spring容器中查找需要使用的对象就可以了；
	这个过程中B对象的创建和组装过程被反转了，之前是使用者自己主动去控制的，
	现在交给spring容器去创建和组装了，对象的构建过程被反转了，所以叫做控制反转；
	IOC是是面相对象编程中的一种设计原则，主要是为了降低系统代码的耦合度，让系统利于维护和扩展。
DI：依赖注入
    依赖注入是spring容器中创建对象时给其设置依赖对象的方式，比如给spring一个清单，
	清单中列出了需要创建B对象以及其他的一些对象（可能包含了B类型中需要依赖对象），
	此时spring在创建B对象的时候，会看B对象需要依赖于哪些对象，然后去查找一下清单中有没有包含这些被依赖的对象，
	如果有就去将其创建好，然后将其传递给B对象；
	可能B需要依赖于很多对象，B创建之前完全不需要知道其他对象是否存在或者其他对象在哪里以及被他们是如何创建，
	而spring容器会将B依赖对象主动创建好并将其注入到B中去，
	比如spring容器创建B的时候，发现B需要依赖于A，那么spring容器在清单中找到A的定义并将其创建好之后，注入到B对象中。
总结
	1.	IOC控制反转，是一种设计理念，将对象创建和组装的主动控制权利交给了spring容器去做，
	控制的动作被反转了，降低了系统的耦合度，利于系统维护和扩展，
	主要就是指需要使用的对象的组装控制权被反转了，之前是自己要做的，现在交给spring容器做了。
	2.	DI依赖注入，表示spring容器中创建对象时给其设置依赖对象的方式，
	通过某些注入方式可以让系统更灵活，比如自动注入等可以让系统变的很灵活。
	3.	spring容器：主要负责容器中对象的创建、组装、对象查找、对象生命周期的管理等等操作。
IOC容器
	IOC容器是具有依赖注入功能的容器，负责对象的实例化、对象的初始化，对象和对象之间依赖关系配置、对象的销毁、对外提供对象的查找等操作，
	对象的整个生命周期都是由容器来控制。
	我们需要使用的对象都由ioc容器进行管理，不需要我们再去手动通过new的方式去创建对象，
	由ioc容器直接帮我们组装好，当我们需要使用的时候直接从ioc容器中直接获取就可以了。

Bean概念
	由spring容器管理的对象统称为Bean对象。
	Bean就是普通的java对象，和我们自己new的对象其实是一样的，
	只是这些对象是由spring去创建和管理的，我们需要在配置文件中告诉spring容器需要创建哪些bean对象，
	所以需要先在配置文件中定义好需要创建的bean对象，这些配置统称为bean定义配置元数据信息，
	spring容器通过读取这些bean配置元数据信息来构建和组装我们需要的对象。
BeanFactory接口
	org.springframework.beans.factory.BeanFactory
	spring容器中具有代表性的容器就是BeanFactory接口，这个是spring容器的顶层接口，提供了容器最基本的功能。
    常用的几个方法
		//按bean的id或者别名查找容器中的bean
		Object getBean(String name) throws BeansException

		//这个是一个泛型方法，按照bean的id或者别名查找指定类型的bean，返回指定类型的bean对象
		<T> T getBean(String name, Class<T> requiredType) throws BeansException;

		//返回容器中指定类型的bean对象
		<T> T getBean(Class<T> requiredType) throws BeansException;

		//获取指定类型bean对象的获取器，这个方法比较特别，以后会专门来讲
		<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);
ApplicationContext接口
	org.springframework.context.ApplicationContext
	这个接口继承了BeanFactory接口，所以内部包含了BeanFactory所有的功能，
	并且在其上进行了扩展，增加了很多企业级功能，比如AOP、国际化、事件支持等等。
ClassPathXmlApplicationContext类
	org.springframework.context.support.ClassPathXmlApplicationContext
	这个类实现了ApplicationContext接口，注意一下这个类名称包含了ClassPath Xml，
	说明这个容器类可以从classpath中加载bean xml配置文件，然后创建xml中配置的bean对象，一会后面的案例就会用到这个类。
AnnotationConfigApplicationContext类
	org.springframework.context.annotation.AnnotationConfigApplicationContext
	这个类也实现了ApplicationContext接口，注意其类名包含了Annotation和config两个单词，上面我们有说过，
	bean的定义支持xml的方式和注解的方式，当我们使用注解的方式定义bean的时候，就需要用到这个容器来装载了，
	这个容器内部会解析注解来构建构建和管理需要的bean。
	注解的方式相对于xml方式更方便一些，也是我们比较推荐的方式，后面我们会大量使用这种方式，具体会详解。
bean xml配置文件格式
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		   xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
		
		<import resource="引入其他bean xml配置文件" />
		<bean id="bean标识" class="玩转类型名称"/>
		<alias name="bean标识" alias="别名" />

	</beans>
    beans是根元素，下面可以包含任意数量的import、bean、alias元素，下面我们对每个元素进行详解。
	bean元素
	用来定义一个bean对象。
	格式
	<bean id="bean唯一标识" name="bean名称" class="完整类型名称" factory-bean="工厂bean名称" factory-method="工厂方法"/>
	bean名称
	每个bean都有一个名称，叫做bean名称，bean名称在一个spring容器中必须唯一，否则会报错，通过bean名称可以从spring容器获取对应的bean对象。
	bean别名
	相当于人的外号一样，一个人可能有很多外号，当别人喊这个人的名称或者外号的时候，都可以找到这个人。
	那么bean也一样，也可以给bean起几个外号，这个外号在spring中叫做bean的别名，spring容器允许使用者通过名称或者别名获取对应的bean对象。
	bean名称别名定义规则
	名称和别名可以通过bean元素中的id和name来定义，具体定义规则如下：：
	1.	当id存在的时候，不管name有没有，取id为bean的名称
	2.	当id不存在，此时需要看name，name的值可以通过,;或者空格分割，
	最后会按照分隔符得到一个String数组，数组的第一个元素作为bean的名称，其他的作为bean的别名
	3.	当id和name都存在的时候，id为bean名称，name用来定义多个别名
	4.	当id和name都不指定的时候，bean名称自动生成，生成规则下面详细说明
	id和name都未指定
	bean的class的完整类名#编号
	上面的编号是从0开始的，同种类型的没有指定名称的依次递增。
	第一个会有别名，别名为完整的类名。bean名称为完整类名#编号。
	alias元素
	alias元素也可以用来给某个bean定义别名，语法：
	<alias name="需要定义别名的bean" alias="别名" />
	import元素
	当我们的系统比较大的时候，会分成很多模块，每个模块会对应一个bean xml文件，我们可以在一个总的bean xml中对其他bean xml进行汇总，
	相当于把多个bean xml的内容合并到一个里面了，可以通过import元素引入其他bean配置文件。
	<import resource="其他配置文件的位置" />
容器创建bean实例有多少种
	Spring容器内部创建bean实例对象常见的有4种方式。
	    通过反射调用构造方法创建bean对象
		  调用类的构造方法获取对应的bean实例，是使用最多的方式，这种方式只需要在xml bean元素中指定class属性，
		spring容器内部会自动调用该类型的构造方法来创建bean对象，将其放在容器中以供使用。
		语法
		<bean id="bean名称" name="bean名称或者别名" class="bean的完整类型名称">
			<constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
			....
			<constructor-arg index="n" value="bean的值" ref="引用的bean名称" />
		</bean>
			constructor-arg用于指定构造方法参数的值
			index：构造方法中参数的位置，从0开始，依次递增
			value：指定参数的值
			ref：当插入的值为容器内其他bean的时候，这个值为容器中对应bean的名称
		通过静态工厂方法创建bean对象
		语法
		<bean id="bean名称" name="" class="静态工厂完整类名" factory-method="静态工厂的方法">
			<constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
			....
			<constructor-arg index="n" value="bean的值" ref="引用的bean名称" />
		</bean>
		class：指定静态工厂完整的类名
		factory-method：静态工厂中的静态方法，返回需要的对象。
		constructor-arg用于指定静态方法参数的值，用法和上面介绍的构造方法一样。
		spring容器会自动调用静态工厂的静态方法获取指定的对象，将其放在容器中以供使用
		通过实例工厂方法创建bean对象
		让spring容器去调用某些对象的某些实例方法来生成bean对象放在容器中以供使用。
		语法
		<bean id="bean名称" factory-bean="需要调用的实例对象bean名称" factory-method="bean对象中的方法">
			<constructor-arg index="0" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="1" value="bean的值" ref="引用的bean名称" />
			<constructor-arg index="2" value="bean的值" ref="引用的bean名称" />
			....
			<constructor-arg index="n" value="bean的值" ref="引用的bean名称" />
		</bean>
		spring容器以factory-bean的值为bean名称查找对应的bean对象，然后调用该对象中factory-method属性值指定的方法，
		将这个方法返回的对象作为当前bean对象放在容器中供使用。
		通过FactoryBean来创建bean对象
		前面我们学过了BeanFactory接口，BeanFactory是spring容器的顶层接口，而这里要说的是FactoryBean，也是一个接口，
		这两个接口很容易搞混淆，FactoryBean可以让spring容器通过这个接口的实现来创建我们需要的bean对象。
Spring系列第6篇：bean作用域scope详解
    应用中，有时候我们需要一个对象在整个应用中只有一个，有些对象希望每次使用的时候都重新创建一个，
	spring对我们这种需求也提供了支持，在spring中这个叫做bean的作用域，xml中定义bean的时候，可以通过scope属性指定bean的作用域
	<bean id="" class="" scope="作用域" /> 
	singleton
	当scope的值设置为singleton的时候，整个spring容器中只会存在一个bean实例，
	通过容器多次查找bean的时候（调用BeanFactory的getBean方法或者bean之间注入依赖的bean对象的时候），
	返回的都是同一个bean对象，singleton是scope的默认值，所以spring容器中默认创建的bean对象是单例的，
	通常spring容器在启动的时候，会将scope为singleton的bean创建好放在容器中
	（有个特殊的情况，当bean的lazy被设置为true的时候，表示懒加载，那么使用的时候才会创建），用的时候直接返回。
	单例bean使用注意
	单例bean是整个应用共享的，所以需要考虑到线程安全问题，之前在玩springmvc的时候，springmvc中controller默认是单例的，
	有些开发者在controller中创建了一些变量，那么这些变量实际上就变成共享的了，
	controller可能会被很多线程同时访问，这些线程并发去修改controller中的共享变量，可能会出现数据错乱的问题；所以使用的时候需要特别注意。
	prototype
	如果scope被设置为prototype类型的了，表示这个bean是多例的，通过容器每次获取的bean都是不同的实例，每次获取都会重新创建一个bean实例对象。
	多例bean使用注意
	多例bean每次获取的时候都会重新创建，如果这个bean比较复杂，创建时间比较长，会影响系统的性能，这个地方需要注意。
    下面要介绍的3个：request、session、application都是在spring web容器环境中才会有的
	request
	当一个bean的作用域为request，表示在一次http请求中，一个bean对应一个实例；
	对每个http请求都会创建一个bean实例，request结束的时候，这个bean也就结束了，
	request作用域用在spring容器的web环境中，这个以后讲springmvc的时候会说，
	spring中有个web容器接口WebApplicationContext，这个里面对request作用域提供了支持
	session
	这个和request类似，也是用在web环境中，session级别共享的bean，每个会话会对应一个bean实例，
	不同的session对应不同的bean实例，springmvc中我们再细说
	application
	全局web应用级别的作用于，也是在web环境中使用的，一个web应用程序对应一个bean实例，
	通常情况下和singleton效果类似的，不过也有不一样的地方，singleton是每个spring容器中只有一个bean实例，
	一般我们的程序只有一个spring容器，但是，一个应用程序中可以创建多个spring容器，
	不同的容器中可以存在同名的bean，但是sope=aplication的时候，
	不管应用中有多少个spring容器，这个应用中同名的bean只有一个。
	自定义scope
    有时候，spring内置的几种sope都无法满足我们的需求的时候，我们可以自定义bean的作用域
总结
	1.	spring容器自带的有2种作用域，分别是singleton和prototype；还有3种分别是spring web容器环境中才支持的request、session、application
	2.	singleton是spring容器默认的作用域，一个spring容器中同名的bean实例只有一个，多次获取得到的是同一个bean；单例的bean需要考虑线程安全问题
	3.	prototype是多例的，每次从容器中获取同名的bean，都会重新创建一个；多例bean使用的时候需要考虑创建bean对性能的影响
	4.	一个应用中可以有多个spring容器
	5.	自定义scope 3个步骤，实现Scope接口，将实现类注册到spring容器，使用自定义的sope
Spring系列第7篇：依赖注入之手动注入

	







	




































